---
layout: post
title: 嵌入式开发——基于总线的计算机系统
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false

---

# 嵌入式开发——基于总线的计算机系统

## 1. 输入与输出

### 1. IO接口与设备

IO接口为了能够充当设备与计算机的桥梁，需要多个寄存器：数据寄存器，控制寄存器，状态寄存器

GPIO：GPIO（通用输入输出）是一种用于与外部设备进行数字通信的通用引脚接口。通过GPIO接口，可以将数字信号传输到外部设备（输出），或从外部设备接收数字信号（输入）。

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/lec5/1.png)

### 2. 分类

系统设备：操作系统启动时已经在系统中注册的标准设备

用户设备：操作系统启动时未在系统中注册的非标准设备



专用设备：单一进程

共享设备：可以被多个进程同时殉职

虚拟设备：通过虚拟技术将一台独占设备虚拟成多台逻辑设备



存储设备：用于存储信息的设备

IO设备：输入设备&&输出设备



（信息交换的基本单元）

块设备：以数据块为单位组织

字符设备：以字符为单位

### 3. IO设备

组成：机械部件，电子部件

UART：通用异步收发器

### 4. 可编程IO

1. 通信期间选择控制寄存器或数据缓冲区的三种方法
   1. 独立的I/O端口：需要专门的指令来完成。
   2. 内存映射的I/O。
   3. 混合解决方案(统一编址)。混合模型包括内存映射的I/O数据缓冲区和用于控制寄存器的单独的I/O端口。
2. 英特尔x86提供了输入输出说明。大多数其他CPU使用内存映射的I/O。
3. I/O指令不排除内存映射的I/O。

[![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/lec5/4.png)](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/lec5/4.png)

1. 独立的I/O和内存空间。
2. 内存映射的I/O。
3. 混合解决方案。

### 5. 内存映射的IO

1. 内存映射I/O的优点可总结为：
   1. 在内存映射的I/O模式下，设备控制寄存器只是内存中的变量，并且可以与其他变量一样用C寻址。因此，可以完全用C语言编写I/O设备驱动程序。
   2. 在这种模式下，不需要特殊的保护机制即可阻止用户进程执行I/O操作。
2. 内存映射I/O模式的缺点可以总结为：
   1. 当前大多数嵌入式处理器都支持内存缓存。缓存设备控制寄存器将导致灾难。为了防止这种情况，必须为硬件提供选择性禁用缓存的功能。这将增加嵌入式系统中硬件和软件的复杂性。
   2. 如果只有一个地址空间，则所有内存模块和所有I/O设备都必须检查所有内存引用，以便确定要响应的内存引用。这会严重影响系统性能。
3. ARM 内存映射的I/O
   1. 定义设备地址:`DEV1 EQU 0x1000`
   2. 读写代码:

```
LDR r1,#DEV1 ; set up device adrs
LDR r0,[r1] ; read DEV1
LDR r0,#8 ; set up value to write
STR r0,[r1] ; write value to device
```

### 6. 存取

### 7. 中断IO

1. 在忙和等待是非常低效的。而中断I/O是相对高效的。
   1. CPU在检查设备的时候，不能干别的。
   2. 很难去实现同步I/O
2. 中断允许设备更改CPU中的控制流:导致子例程调用以处理设备。

#### 中断行为

1. 基于子程序的调用机制
2. 中断迫使下一条指令成为子程序调用到预定位置。
3. 返回地址被保存以恢复执行前台程序。

#### 中断物理接口

1. CPU和设备通过CPU总线连接。
2. CPU和设备握手：
3. 设备声明中断请求；
4. CPU可以处理中断时会声明中断确认。

#### 带缓冲区的中断IO

### C语言还是汇编语言

汇编：容易得到代码允许复杂度的临界估计

C语言：无法进行估计

### 调试INT/INTA周期

1. 设备硬件产生中断脉冲。
2. 中断控制器(如果有)对多个同时请求进行优先级排序，并向处理器发出单个中断。
3. CPU响应一个中断应答周期。
4. 控制器在数据总线上放置一个中断向量。
5. CPU读取该向量，并计算用户在存储器中存储的向量的地址。 然后，它获取此值。
6. CPU推送当前上下文，禁用中断，然后跳转到ISR。

### 查找丢失的中断

1. 您可以使用一个递增/递减计数器建立一个小的电路，该计数器对每个中断进行计数，并减少每个中断应答的计数。如果计数器始终显示零或一的值，则一切正常。
2. 一种设计经验法则将有助于最大程度地减少丢失的中断：在最早的安全位置重新启用ISR中的中断。

### 断点问题 

虽然断点确实是很棒的调试辅助工具，但是对于嵌入式代码 就像海森堡的不确定性原理一样 

通过使用实时trace，这是所有仿真器和一些智能逻辑分析仪 都具有的功能。

### 可重用代码

1. 在嵌入式世界中，例程必须满足以下条件才能重新进入：
   1. 它以原子方式使用所有共享变量，除非每个共享变量都分配给该函数的特定实例。
   2. 它不调用非可重入函数。
   3. 它不会以非原子方式使用硬件。
2. 可重用，就是被中断之后还可以再次进入

### 原子变量

```
mov ax, bx 原子式
temp = foobar; temp += 1; foobar = temp; 非原子
foobar += 1; 非原子？先加法，再移动

mov ax,[foobar]
inc ax
mov [foobar],ax;非原子

inc [foobar];非原子，先从寄存器中读，然后加载进来两步骤
lock inc [foobar]; 将总线锁死
```

> 规则2告诉我们调用函数继承了被调用者的重入问题
> 规则3是唯一嵌入的警告。硬件看起来很像一个变量。如果处理一个设备需要多个I / O操作，则会产生重入问题。

### 保持代码可重入性

消除不可重入代码

1. 避免共享变量。全局变量是代码失败的根源。使用自动变量或动态分配内存。
2. 最常见的办法是在不可重入代码期间禁止中断
3. 信号量

### 递归函数

1. 如果函数调用自身，则该函数是递归的。
2. 因此，所有递归函数都必须是可重入的……但并非所有可重入函数都是递归的。
3. 嵌入式不建议使用递归，核心栈空间可能不足、执行时间比较复杂。

### 异步硬件/固件

```
//QAR 公司 RTEMS
int timer_hi;
interrupt timer(){//中断，让高时间位自增1
   ++timer_hi;
}
long timer_read(void){
   unsigned int low, high;
   // 这里有问题，读硬件的时候值是ffffff
   low =inword(hardware_register);//存在被ISR抢断的情况，比如产生了溢出
   high=timer_hi;
   return (high<<16+low);
}
```

#### 竞态条件

设备或系统出现不恰当的执行时序，从而得到不正确的结果

1. timer_read的错误条件之一可能是：(顺序变化导致的结果变化，重要)
   1. 它读取硬件，并获得0xffff的值。
   2. 在有机会从变量timer_hi检索大部分时间之前，硬件将再次递增至0x0000。
   3. 溢出触发中断。ISR运行。timer_hi现在为0
   4. 0001，而不是0，因为它只是十亿分之一秒。
   5. ISR返回；我们无所畏惧的timer_read例程，不知道发生了中断，巧妙地将新的0连接起来
   6. 0001，以前读取的计时器值为0Xffff，并返回0X1ffff，这是一个非常不正确的值。

解析：

1. 在timer_read函数中，读取硬件寄存器的操作可能会在中断服务程序（ISR）执行期间发生。由于ISR可能会在读取低位值之前修改硬件寄存器的值，因此可能会导致读取到0xFFFF的值。
2. 在ISR中，timer_hi变量会在溢出时自增。然而，在ISR运行后返回到timer_read函数之前，有可能再次发生溢出并触发另一个中断。在这种情况下，timer_hi会被重置为0，而不是期望的1。

解决方法：

1. 最简单的方法是在尝试读取计时器之前将其停止:失去时间。在此期间关闭中断将消除不必要的任务，但会增加系统延迟和复杂性。

2. 另一种解决方案是先读取timer_hi变量，然后读取硬件计时器，然后重新读取timer_hi。 如果两个变量值都不相同，则会发生中断。迭代直到两个变量读取相等。

   1. 好处是：正确的数据，中断持续存在，并且系统不会丢失计数。
   2. 缺点：在负载繁重的多任务环境中，该例程可能会循环很长时间才能获得两次相同的读取。 函数的执行时间不确定。 我们已经从非常简单的计时器读取器转变为可以运行几毫秒而不是微秒的更为复杂的代码。

3. 另一种选择是简单地禁用读取周围的中断。

   ```
   long timer_read(void){
      unsigned int low, high;
      push_interrupt_state;
      disable_interrupts;
      low=inword(Timer_register);
      high=timer_hi;
      if(inword(timer_overflow)){
         ++high;
         low=inword(timer_register);
      }
      pop_interrupt_state;
      return (((ulong)high)<<16+(ulong)low);
   }
   ```

## 2. 总线

### 1. CPU总线

1. 总线允许CPU，内存，设备进行通信
2. 总线是一组电线，通信协议

### 2. 总线协议

1. 总线协议决定了设备如何进行通信
2. 总线上的设备会经历状态序列：协议是由状态机指定的，协议中的每个参与者都有一个状态机
3. 可能包含异步逻辑行为

### 3. 总线复用

总线复用（Bus Multiplexing）是一种技术，通过在不同的时间段共享同一条物理总线来传输多个设备之间的数据和控制信号。

- 时间分割：每个设备在不同的时间段上使用总线。例如，设备A在一个时间段上使用总线进行数据传输，然后释放总线，接着设备B在下一个时间段上使用总线。
- 频率分割：总线的时钟频率被分割成不同的子频率，每个设备在一个子频率上进行数据传输。这样不同设备可以同时使用总线，但在不同的频率上。
- 空间分割：总线被分割成不同的物理通道，每个设备分配一个独立的通道。每个设备可以同时使用自己的通道进行数据传输。

### 4. 系统总线配置

1. 多个总线允许并行处理：
   1. 一条总线上的设备慢。
   2. 快速设备位于单独的总线上。
2. 桥连接两条总线。
3. PC端类似，使用南桥和北桥来完成，北桥连接CPU

### 5. ARM AMBA总线

1. 两个类别:
   1. AHB是高性能的。
   2. APB是低速，低成本的。
2. AHB支持流水线，突发传输，拆分事务，多个总线主控。
   1. H:高速
3. 所有设备都是APB上的从设备。
   1. APB是外部

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Introduction-to-Embedded-Systems/img/lec5/20.png)

