---
layout: post
title: 软件测试——模糊测试
categories: [软件测试, 模糊测试]
description: some word here
keywords: 软件测试, 模糊测试
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false

---

# 软件测试——模糊测试

## 1. 起源于发展

跳过

## 2. 概念与框架【重点】

### 2.1 什么是Fuzzing

generate some inputs, make some noises and 

执行过程：

1. 测试工具通过随机或是半随机的方式生成大量数据；
2. 测试工具将生成的数据发送给被测试的系统（输入）；
3. 测试工具检测被测系统的状态（如是否能够响应，响应是否正确等）；
4. 根据被测系统的状态判断是否存在潜在的安全漏洞。

### 2.2 三个要素

一个工具，一个目标，一个循环

![截屏2023-09-21 15.41.49](https://github.com/ShadowOnYOU/images/blob/main/test202309211541306.png?raw=true)

### 2.3 一些术语

- 模糊(Fuzzing)与模糊测试(Fuzz Testing)
  - 模糊：指从输入空间采样得到的输入来执行待测程序的过程。该模糊输入空间代表着测试人员针对待测程序定义的预期输入。
  - 模糊测试：一种应用模糊来验证待测程序是否违反正确性策略的测试技术
- 模糊器(Fuzzer)【核心组件】
  - 模糊器是一个或一组用于实现模糊测试的程序

- 模糊运动(Fuzzing Campaign) 
  - 模糊运动指一个模糊器按照一组特定的正确性政策在一个给定待测程序上的一次具体的执行
- 缺陷预言(Bug Oracle)
  - 一个用于确定一次给定执行是否违反具体正确性策略的程序
- 模糊配置(Fuzz Configuration)
  - 一组控制和描述模糊（测试）算法的数据和约束
- 测试输入(Test Input)、测试用例(Test Case)与种子 输入(Seed Input)
  - **测试输入**是一组用于驱动待测程序执行的数据
  -  **测试用例**是一组用于确定应用软件或软件系统是否能够正确工 作的条件或变量3 à 输入 + 逻辑(调用序列) + 预言
  - **种子输入**是一个或一组在模糊测试过程中为输入生成(Input Generation)提供基准的测试输入，简称**种子**(Seed)。

### 2.4 模糊测试框架

![截屏2023-09-21 16.14.56](https://github.com/ShadowOnYOU/images/blob/main/test202309211614076.png?raw=true)

## 3. 家族与分类

### 3.1 模糊测试分类

- 按照**采用的运行时信息**:黑盒、灰盒、白盒
  - 黑盒：
    - 不监控执行过程，也不使用执行过程中产生的任何信息，仅从输入和输出端入手优化模糊测试
  - 白盒
    - 使用混合执行、五点分析等比较昂贵的白盒分析技术优化模糊测试过程
  - 灰盒
    - 采用轻量级插装对程序进行监控，在执行过程中收集各类信息，如分支覆盖、线程执行、堆栈状态等
- 按照**输入生成的策略**:Input Generator、Mutation-based
  - M：将种子输入转换为比特串(Bits)，对比特串进行变换
- 按照**引导过程**:Search-based(一些启发式算法)，Gradient- based(梯度下降)
- 按照**测试的目的**:定向、非定向、某一类缺陷
- 按照**应用领域**:网络协议、Compiler、DNN、IoT、内核
- 按照**优化角度**:种子调度、变异策略、能量调度、过程建模

## 4. 自己补充的东西——参考一篇知乎文档

https://zhuanlan.zhihu.com/p/43432370

Fuzzing技术是一种基于黑盒（或灰盒）的测试技术，通过自动化生成并执行大量的随机测试用例来发现产品或协议的未知漏洞。随着计算机的发展，Fuzzing技术也在不断发展。

计算机是精确的科学和技术，测试技术应该也是一样的，有什么的输入，对应什么样的输出，都应该是明确的，怎么会有模糊不确定的用例呢？这些不确定的测试用例具体会有什么作用呢？

为什么会有不确定的测试用例，我想主要的原因是下面几点：

1、我们无法穷举所有的输入作为测试用例。我们编写测试用例的时候，一般考虑正向测试、反向测试、边界值、超长、超短等一些常见的场景，但我们是没有办法把所有的输入都遍历进行测试的。

2、我们无法想到所有可能的异常场景。由于人类脑力的限制，我们没有办法想到所有可能的异常组合，尤其是现在的软件越来越多的依赖操作系统、中间件、第三方组件，这些系统里的bug或者组合后形成的bug，是我们某个项目组的开发人员、测试人员无法预知的。

3、Fuzzing软件也同样无法遍历所有的异常场景。随着现在软件越来越复杂，可选的输入可以认为有无限个组合，所以即使是使用软件来遍历也是不可能实现的，否则你的版本可能就永远也发布不了。Fuzzing技术本质是依靠随机函数生成随机测试用例来进行测试验证，所以是不确定的。



目前，Fuzzing技术已经是软件测试、漏洞挖掘领域的最有效的手段之一。Fuzzing技术特别适合用于发现0 Day漏洞，也是众多黑客或黑帽子发现软件漏洞的首选技术。Fuzzing虽然不能直接达到入侵的效果，但是Fuzzing非常容易找到软件或系统的漏洞，以此为突破口深入分析，就更容易找到入侵路径，这就是黑客喜欢Fuzzing技术的原因。



Fuzzing引擎算法中，测试用例的生成方式主要有2种：

1）基于变异：根据已知数据样本通过变异的方法生成新的测试用例；

2）基于生成：根据已知的协议或接口规范进行建模，生成测试用例；
