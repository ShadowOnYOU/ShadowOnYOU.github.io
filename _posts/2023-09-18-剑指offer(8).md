---
layout: post
title: 剑指offer(8)——模拟
categories: [剑指offer, 模拟]
description: some word here
keywords: 剑指offer, 模拟
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false

---

# 剑指offer(8)——模拟

## 题目29:

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

**示例 1：**

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

 

**限制：**

- `0 <= matrix.length <= 100`
- `0 <= matrix[i].length <= 100`

注意：本题与主站 54 题相同：https://leetcode-cn.com/problems/spiral-matrix/

### 我的解法：

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int left, right, top, end;
        vector<int> t;
        left = 0, top = 0;
        if(matrix.size() == 0){
            return t;
        }
        right = matrix[0].size() - 1;
        end = matrix.size() - 1;

        return my_print(matrix, left, right, top, end, t);
    }

    vector<int> my_print(vector<vector<int>>& matrix,int left,int right, int top, int end, vector<int> t){
                int a1 = 0, a2 = 0, a3 = 0, a4 = 0;
        if(left > right || top > end){
            return t;
        }
        if(left == right && top == end){
            t.push_back(matrix[top][left]);
            return t;
        }
        if(left == right){
            for(int i = top;i <= end;i++){
                t.push_back(matrix[i][right]);
                a2 = 1;
            }
            return t;
        }
        if(top == end){
            for(int i = left;i <= right;i++){
                t.push_back(matrix[top][i]);
                a1 = 1;
            }
            return t;
        }
        // 第一行除去最后一个
        for(int i = left;i < right;i++){
            t.push_back(matrix[top][i]);
            a1 = 1;
        }
        // 最右边的一列
        for(int i = top;i < end;i++){
            t.push_back(matrix[i][right]);
            a2 = 1;
        }
        for(int i = right;i > left;i--){
            t.push_back(matrix[end][i]);
            a3 = 1;
        }
        for(int i = end;i > top;i--){
            t.push_back(matrix[i][left]);
            a4 = 1;
        }
        if(a1 == 1){
            top ++;
        }
        if(a2 == 1){
            right--;
        }
        if(a3 == 1){
            end--;
        }
        if(a4 == 1){
            left++;
        }
        vector<int> next = my_print(matrix, left, right, top, end, t);
        return next;
    }
};
```

我的思路主要是像剥皮一样，一次处理一行或一列的输出，不断重复。

### 解题方法1:模拟

可以模拟打印矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。

判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited\textit{visited}visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited\textit{visited}visited 中的对应位置的元素设为已访问。

如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。

```c++
class Solution {
private:
    static constexpr int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return {};
        }
        
        int rows = matrix.size(), columns = matrix[0].size();
        vector<vector<bool>> visited(rows, vector<bool>(columns));
        int total = rows * columns;
        vector<int> order(total);

        int row = 0, column = 0;
        int directionIndex = 0;
        for (int i = 0; i < total; i++) {
            order[i] = matrix[row][column];
            visited[row][column] = true;
            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn]) {
                directionIndex = (directionIndex + 1) % 4;
            }
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return order;
    }
};
```

## 题目31

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

 

**示例 1：**

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

**示例 2：**

```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

 

**提示：**

1. `0 <= pushed.length == popped.length <= 1000`
2. `0 <= pushed[i], popped[i] < 1000`
3. `pushed` 是 `popped` 的排列。

注意：本题与主站 946 题相同：https://leetcode-cn.com/problems/validate-stack-sequences/

### 解法1:栈模拟

这道题需要利用给定的两个数组 pushed\textit{pushed}pushed 和 popped\textit{popped}popped 的如下性质：

数组 pushed\textit{pushed}pushed 中的元素互不相同；

数组 popped\textit{popped}popped 和数组 pushed\textit{pushed}pushed 的长度相同；

数组 popped\textit{popped}popped 是数组 pushed\textit{pushed}pushed 的一个排列。

根据上述性质，可以得到如下结论：

栈内不可能出现重复元素；

如果 pushed\textit{pushed}pushed 和 popped\textit{popped}popped 是有效的栈操作序列，则经过所有的入栈和出栈操作之后，每个元素各入栈和出栈一次，栈为空。

因此，可以遍历两个数组，模拟入栈和出栈操作，判断两个数组是否为有效的栈操作序列。

模拟入栈操作可以通过遍历数组 pushed\textit{pushed}pushed 实现。由于只有栈顶的元素可以出栈，因此模拟出栈操作需要判断栈顶元素是否与 popped\textit{popped}popped 的当前元素相同，如果相同则将栈顶元素出栈。由于元素互不相同，因此当栈顶元素与 popped\textit{popped}popped 的当前元素相同时必须将栈顶元素出栈，否则出栈顺序一定不等于 popped\textit{popped}popped。

根据上述分析，验证栈序列的模拟做法如下：

遍历数组 pushed\textit{pushed}pushed，将 pushed\textit{pushed}pushed 的每个元素依次入栈；

每次将 pushed\textit{pushed}pushed 的元素入栈之后，如果栈不为空且栈顶元素与 popped\textit{popped}popped 的当前元素相同，则将栈顶元素出栈，同时遍历数组 popped\textit{popped}popped，直到栈为空或栈顶元素与 popped\textit{popped}popped 的当前元素不同。

遍历数组 pushed\textit{pushed}pushed 结束之后，每个元素都按照数组 pushed\textit{pushed}pushed 的顺序入栈一次。如果栈为空，则每个元素都按照数组 popped\textit{popped}popped 的顺序出栈，返回 true\text{true}true。如果栈不为空，则元素不能按照数组 popped\textit{popped}popped 的顺序出栈，返回 false\text{false}false。

```c++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        stack<int> st;
        int n = pushed.size();
        for (int i = 0, j = 0; i < n; i++) {
            st.emplace(pushed[i]);
            while (!st.empty() && st.top() == popped[j]) {
                st.pop();
                j++;
            }
        }
        return st.empty();
    }
};
```

