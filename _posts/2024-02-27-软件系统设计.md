---
layout: post
title: 软件系统设计
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 软件系统设计

课件：学院moodle

作业，签到，互动

详细设计 + 架构设计

作业之间相关

量很大

掌握主要的设计思想与设计的模式

潘 8 周 12 次课 2次不签到不扣分

鼓励发言？？？？1 次 0.5 分数不加在期末成绩中

## 软件设计

需求，规约，架构，设计

需求：非规范化的。规约：规范化的

架构：非功能属性

设计决定了代码未来的可维护性，可服用行等

## OOD 面向对象设计

将实现的约束条件应用到面向对象分析所产生的概念模型的过程

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec01/1.png)

### OOA - > OOD -> OOP

1. 可行性预研究阶段，评估需求是否合理，能否实现
2. OOA：此阶段分析用例，定义领域模型
   1. 面向对象分析。把现实的需求转义为领域模型问题，以及输出领域模型。领域模型也就是我们常说的业务逻辑。会输出概念类，概念类的交互的关系，这部分概念类一般直接反映现实的事物。
3. OOD：此阶段定义类图，类之间的交互图
   1. 面向对象设计。此过程是把我们的领域模型转为逻辑架构
   2. 如何分层，如何分包，如何保证高内聚低耦合都是这部分要考虑的问题。
4. OOP：此阶段根据OOD设计的类图，类之间的交互图输出代码
   1. 面向对象编程，也就是把我们OOD的设计结果转化为代码。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201031163739908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dmZWlp,size_16,color_FFFFFF,t_70#pic_center)

Ooa：直接来源于问题的领域对象

ood：一个可用的设计如何变得更好

1. 首先已经有一个系统架构(系统架构中有不同的组件)
2. 然后针对问题分析，得到OOA的概念模型
3. 然后我们进行OOD的面向对象设计，添加了一些不明显属于领域的类
4. 最后我们可以直接映射到OOP

重点：设计的风险点

**OOD的难点在于将系统分解为对象**

许多对象直接来源于分析模型，实现空间

同样，还有其他类没有这样的对应类。例如使用策略模式，添加类以实现策略模式。

### 从OOA 到 OOD

这个过程需要经验。

1. 你需不需要实现这部分的类型
2. 需要做设计时，如何进行设计

技术变化可能导致设计经验被淘汰，但是设计原则以及一些经典的设计经验不会褪色。

## 7个设计原则

原则骤减不是孤立存在的，相互依赖，相互补充

单一职责：对未来的变化的估计，体现的是封装的思想

​	一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中

​	就一个类而言，应该仅有一个引起它变化的原因

​	数据职责（属性）行为职责（方法）

​	单一职责是实现高内聚、低耦合的指导方针

开闭

​	一个软件实体应当对扩展开放，对修改关闭

1. 对扩展开放（Open for extension）：这意味着我们应该通过添加新的代码来增加功能或修改行为，而不是直接修改现有的代码。我们可以通过继承、接口实现、组合等方式来实现扩展，而不是直接修改已有的代码。这样做可以保持现有的代码稳定，尽量避免引入新的错误。
2. 对修改关闭（Closed for modification）：这意味着一旦一个类或模块被设计和实现后，就不应该再对其进行修改。即使需求变化，我们也应该通过扩展来适应新的需求，而不是直接修改原有的实现。通过这种方式，我们可以保持代码的稳定性和可靠性，减少对现有系统的影响。

​	软件实体可以指一个软件模块，一个由多个类组成的局部结构或一个独立的类

​	当新需求出现时，总是要修改，但是我们希望尽可能不修改代码

​	为什么我们更推荐不修改之前的代码：测试，安全性更高。你如果写得好，每个模块之间的交互不用测试【例子：排序算法，实现了在接口上承诺的契约。原本代码的耦合和依赖非常小】

​	抽象化 是 开闭原则的关键（变化被封装在内部，在外部是看不到的）

​	有时候继承 和 抽象有些不太好：继承层级关系过于复杂，子类和父类的紧耦合关系，难以扩展。

里氏替换

​	所有引用基类的地方必须能透明的使用其子类的对象

​	原来父类中支持的行为子类也能保持下去。

​	**在子类中添加父类没有的方法是否符合里氏替换**？？？：在子类中添加父类没有的方法不符合里氏替换原则（Liskov Substitution Principle，LSP）。里氏替换原则是指，在面向对象设计中，子类对象应该能够替换父类对象并且程序仍然能够正常运行，而不会引发意外行为或破坏程序的正确性。换句话说，子类应该能够完全替代父类，而不需要对调用方做任何修改。当子类添加了父类没有的方法时，调用方在将父类对象替换为子类对象时，可能会调用到子类特有的方法，这可能导致意外行为或逻辑错误。这违背了里氏替换原则，因为子类无法完全替代父类，无法在不修改调用方的情况下正常工作。符合里氏替换原则的设计要求子类在继承父类时，只能扩展或重写父类已有的方法，不能添加新的方法或改变原有方法的行为。通过遵循里氏替换原则，可以确保代码的可靠性、可扩展性和可维护性，同时保持调用方对抽象的依赖，而不依赖于具体的子类实现。

​	使用基类对象的地方都能使用子类对象，因此 TODO

​	子类中避免扩展父类中没有的方法

依赖倒转

​	要针对接口编程，不要针对实现编程，代码要依赖于抽象的类，而不要依赖于具体的类。

​	上层依赖抽象层，下层也依赖抽象层

​	19min 左右 忘记听了 TODO

​	实现的方法：在代码中使 用抽象类，而将具体类放在配置文件中

​	重点：抽象化

接口隔离

​	客户端不应该依赖那些它不需要的接口（进行接口粒度的细分）

​	一个接口只代表一个角色，接口仅仅需要提供客户端需要的行为或方法， 

​	30min左右 又忘记听了 TODO

​	体现的还是一种定制化的封装思想。

合成复用

​	尽量使用对象组合，而不是继承来达到复用的目的

​	继承复用（白箱复用），组合/聚合复用（黑箱复用）

​	组合聚合可以使系统更加灵活，类之间的耦合度降低，因此慎重使用继承复用

迪米特

​	最小知识原则

​	每一个软件单位对其他的单位只有很少的知识，而且局限于那些与本单位密切相关的软件单位。

**不好的系统造成的原因**：过于僵硬，过于脆弱，复用率低，黏度过高，降低模块类之间的耦合度

**好的系统具备的特性**：可扩展性，灵活性，可插入性（灵活的可替换）

重构是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec01/3.png)

复用性，重用性，可维护性

例子：链表的遍历

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec01/4.png)

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec01/5.png)

例子：display和数据库变化都会产生变化



# 策略模式

设计原理

封装变化：对应开闭原则，识别应用中将变与不变的分开，将变化的部分封装起来

面向接口，而非面向实现：依赖倒转原则



讲了很长时间就是一个策略模式

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec02/20.png)

添加一个火箭：唯一需要修改的是new一个instance

合成：合成复用原则



抽象成经验：

算法族：

环境类 + 一个抽象类 + 针对抽象类的具体实现

让我们在模式级别进行思考，而非具体的对象级别

目的：定义一个算法族，封装每个算法并使他们可替换。策略模式使算法可以独立于使用该算法的客户端而变化。

适用性（设计模式最重要的部分）：

在以下情况下使用策略模式（一般而言是彼此分离的，一般一个模式只能解决一个情况）

1. 许多相关的类仅在**行为**上有所不同，策略提供了一种使用多种行为之一配置类的方法（每一个类有一个适合他的行为）
2. 您需要**算法的不同变体**。例如，您可能定义了反映不同空间/时间权衡的算法。将这些变体实现为算法的类层次结构时，可以使用策略。
3. 一种算法使用客户端不应该知道的数据。使用策略模式**可避免暴露复杂的、特定于算法的数据结构**
4. 一个类定义了许多行为，这些行为在其操作中显示为多个条件语句。代替许多条件，将相关的条件分支移到他们自己的**策略类**中。（**一个类定义了多个行为**，鸭子的例子是子类通过覆盖父类，例子就是如果多一个吃饭的函数，有人喂和自己去吃）

结果：

1. 相关算法家族。策略类的层次结构定义了一系列算法或行为，以供上下文重用。继承可以帮助排除算法的通用功能。
2. 子类化的替代方法
3. 策略消除条件语句
4. 提供多种实现方法，为相同的行为提供不同的实现
5. 增加策略和环境类的通信开销
6. 对象数量的增加
7. 模式一般都会有的缺点：
   1. 增加设计的复杂度和增加类的个数(增加辅助类)
   2. 增加隔阂、方法调用，降低软件运行的效率，但是已经不是目前主要的问题了
8. 客户必须意识到不同的策略，这种模式有一个潜在的缺点，即**客户在选择合适的策略之前必须先了解策略的不同**，不然客户可能会遇到实现问题。（你需要自己把fly的策略传进去，并知道哪个策略是最合适的）
9. java的加密方式、时间显示算法是通过策略模式实现的



policy：用于写代码类的后缀



# 工厂模式

简单工厂模式：**根据参数的不同返回不同的实例**

最大问题：工厂类的职责过重，

应用：权限管理

java日期，java加密技术，

优点：实现了对责任的分割，提供了专门的工厂类用于创建对象

缺点：集成了所有产品，系统易受影响；会增加系统中类的个数；系统的扩展困难，一旦添加新的产品就不得不修改工厂逻辑（违背了开闭原则）。

环境：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。



![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec03/3.png)

设置一个抽象类



# 工厂方法模式

背景：有了新建工厂方法，但是添加新的产品存在问题

违背了开闭原则，所以希望进行改变

**将具体按钮的创建过程交给专门的工厂子类去完成。**先定义一个抽象的按钮工厂类，再定义具体的按钮生产工厂。

定义：也称工厂模式，也叫虚拟构造器模式或多态工厂

```java
// 抽象工厂类代码
public abstract class PayMethodFactory
{
  public abstract AbstractPay getPayMethod();
}
// 具体工厂类代码
public class CashPayFactory extends PayMethodFactory{
  public AbstractPay getPayMethod(){
    return new CashPay();
  }
}
// 客户类代码片段
PayMethodFactory factory;
AbstractPay payMethod;
factory=new CashPayFactory();
payMethod =factory.getPayMethod();
payMethod.pay();
```

工厂父类负责定义创建产品对象的公共接口，而工厂子类负责生成具体的产品对象

目的：将产品类的实例化操作延迟到工厂子类中完成（延迟实例化：尽量使用抽象类来编程）

利用依赖倒转提升代码的可用性

**在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做**。

很好的符合了“开闭原则”。（评判标准只关注：类的内部是否修改（此例子中就是工厂类内部是否需要修改））

工厂模式方法能否支持某个具体的工厂生成多种对象？是可以的。（这个具体的工厂作为一个简单工厂）而简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好。**工厂方法模式退化(抽象工厂和具体工厂合并)后可以演变成简单工厂模式**。

为何会出现上述的需求：类太多了。

实例：日志记录器（同时也可以使用策略模式）

【考试】联合使用多种模式实现某个要求

缺点：增加了类的个数；增加了系统的抽象性和理解难度

工厂模式是简单工厂的升级

# 抽象工厂模式

两个概念：产品等级结构（产品的继承结构），产品族（位于不同产品等级结构的一组产品）

最为抽象，最具一般性的

工厂方法进化到抽象工厂不是为了应对变化。

定义：**提供一个创建一系列相关或相互依依赖对象的接口，而无需制定它们具体的类**。又称为kit模式

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec03/8.png)

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec03/11.png)

实例：电器工厂，数据库操作工厂

能否很好的支持开闭？（增加类符合开闭）但是不完全支持开闭，例如增加新的产品等级结构（例如我加一个微波炉我需要在工厂中添加一个方法）

优点

**模式扩展**：抽象工厂有最多的关系，当我们退化掉部分的组合关系之后，就退化成工厂方法模式。工厂方法退化掉继承变成简单工厂。



抽象工厂模式的这种性质称为“开闭原则”的倾斜性。为新产品族的增加提供方便，但是不能为新的产品等级结构的增加提供便利



# 设计模式

## 建造者模式（生成器模式）

建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。

创建一个复杂的的对象的过程：有不变的封装过程

这些部件的组成往往被外部化到一个称作建造者的对象里

定义：将一个复杂对象的构建与它的表示分离（设计方式），使得同样的构建过程可以构建不同的表示（设计目的）

策略模式：对象模式

工厂方法：类模式

抽象工厂：对象模式

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec04/2.png)

指挥者：决定build的先后顺序

指挥者和建造者的**合成关系**（可以动态的调整行为）

建造者模式：对象创建性模式

引入指挥者类的作用：隔离了客户与生产过程，负责控制产品的生成过程

为何不进一步的构建一个抽象类？没有必要，且违背初衷（因为无需知道内部的具体构造细节）

KFC：服务员是指挥者

优点：

1. 在建造者模式中，**客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象**。
2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，**用户使用不同的具体建造者即可得到不同的产品对象**。
3. **可以更加精细地控制产品的创建过程**。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
4. **增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合"开闭原则"**。

缺点：

1. 使用的频度相对有限（组成部分相似，组成过程复杂）
2. 内部变化复杂可能会导致需要定义很多具体建造者类

适应环境：

1. 需要生成的产品对象有**复杂的内部结构**，这些产品对象通常包含多个成员属性。
2. 需要生成的产品对象的**属性相互依赖，需要指定其生成顺序**。
3. 对象的创建过程独立于创建该对象的类。**在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中**。
4. 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。

应用：

1. javamail
2. 游戏中的地图或任务

简化：（不要过度设计）

1. 神略抽象建造者角色
2. 省略指挥者角色

建造者模式 & 抽象工厂的区别？

1. 建造者返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品
2. 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。

组建过程相关性 和 组建过程有序性（抽象工厂 + 创建者）

## 原型模式

动机：在面向对象系统中，使用原型模式来复制一个自身对象，从而克隆出多个与原型对象一摸一样的对象。原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象

定义：原型模式是一种对象创建型模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。**原型模式允许一个对象再创建另外一个可定制的对象，无须知道任何创建的细节**。（目的）

* 抽象类改为接口行不行？主要是能否复用父类中的实现

 能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。（实际是从object继承过来的）

优点：简化创建过程，动态增减类，简化的创建结构

缺点：需要为每一个类配备一个克隆方法

使用场景：

1. 创建新对象成本较大
2. 如果系统要保存对象的状态
3. 需要避免使用分层次的工厂类来创建分层次的对象

模式扩展：

带原型管理器的原型模式

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec04/6.png)

## 状态模式

动机：一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做**状态**，这样的对象叫做**有状态的(stateful)对象**，这样的对象状态是从事先定义好的一系列值中取出的。

我们要做的就是设计有状态的变化，让他根据状态进行变化

一个UML状态图只描述一个对象

因此可以**将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类**（模式是**透明**的；状态模式是通过合成实现的，避免了改变类型），而实际上是**由于切换到不同的具体状态类实现的**。

从变化上做 比 在逻辑上做好



状态模式 && 策略模式：

1. 使用目的不同：模式自身不同状态下行为切换（完全透明），选择策略（需要外界，符合开闭）
2. 两者都是行为型模式
3. 

实际上是完全一样的



为什么Room不能只剩set？？？？【没听懂】

context尽可能的承担数据职责

能否再完全的支持开闭原则：新增加一个状态（装修状态），则需要有状态转换到该状态（需要新的切换语句）。初始的状态还是需要进行修改的。或者是checkstatus也是需要加一个if分支



状态模式产生了具体耦合。两个彼此自动切换的状态之间一定是具体耦合的；而策略模式是好的



**注意**：行为引发的状态（状态类）。数据引发的状态（放在上下文类）。

优点 && 缺点

适用场景：有很多if else的时候考虑用状态模式 ｜ 策略模式

模式扩展：

共享状态：将这些状态对象定义为环境的静态成员对象

简单状态模式：其实就是策略

可切换状态的状态模式：

触发者：具体状态类，环境类



# 命令模式

使用频度挺高的，在很多系统的架构中用到

动机：在软件设计中，我们经常**需要向某些对象发送请求**，但是并**不知道请求的接收者是谁**，**也不知道被请求的操作是哪个**，我们**只需在程序运行时指定具体的请求接收者即可**，此时，可以使用命令模式来进行设计，使得**请求发送者与请求接收者消除彼此之间的耦合**，让对象之间的调用关系更加灵活。

如何解除两个类之间的耦合：抽象耦合 && 封装一个其他类进行转发

定义：阐述了唯三的场景（对象行为型模式）

1. 对客户进行参数化
2. 对请求排队或记录请求日志
3. 支持可撤销的操作

invoker：可以排队，可以调度

本质：对命令进行封装，将发出命令的责任和执行命令的责任分隔开

call可以有外部决定，也可以内部构建一个算法

* 在c++中，若你的动作是无参的，则可以用函数指针

其实在command中有两个函数：execute，undo（取决于上一个行为是什么）

？如何实现undo呢？：每个command实现自己的undo，然后我只需要知道上一个执行的command就行了

其实undo很难实现：日志：快照，然后重新执行一遍（多store(),retrieve()）

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec05/11.png)



宏命令（组合命令）：在execute里面把所有的操作堆起来（xxx.on,xxx.on）。这样很多的receiver之间产生了具体耦合。【结构非常重要】

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec05/12.png)

如何实现呢？首先为每个独立的电器做一个命令。我再创建一个新的command，而是**维持一个arraylist**，这样我的执行就只需要做那个list中的遍历各种receiver中的exe（）（其实是一个递归，到每一个原子的命令就是终止）。宏命令还可以作为原子命令继续用在其他的命令里。

如何实现宏的undo：反向遍历

如何实现很多的undo，在invorker里面实现一个栈

使用环境：

# 中介者模式

迪米特法则：所有对象中间引入一个中介对象。

模式动机中的问题都是强耦合导致的。希望称为一个松耦合的系统

定义：使用一个中介对象来封装一系列的对象交互，是对象行为型模式

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec06/9.png)

mediator也是抽象：仍然支持开闭原则，实现灵活的修改（踢一个人）

中介者的职责【有点重要】：中转（结构性）， 协调（行为性）

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec06/11.png)

优点 && 缺点：

什么场景下使用：对象之间存在复杂的饮用关系，存在难以复用该对象，想通过——

中介者模式与迪米特相关：非常有效的降低系统耦合

# 观察者模式



开始的代码：无法满足4，产生了具体耦合

体现的原则并如何做：解决具体耦合的方法：抽象和封装。对三个display抽象出三个update方法

动机：

1. 建立一种

   对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。

   1. 发生改变的对象称为**观察目标**
   2. 被通知的对象称为**观察者**

2. **一个观察目标可以对应多个观察者**，而且这些观察者之间没有相互联系，**可以根据需要增加和删除观察者，使得系统更易于扩展**，这就是观察者模式的模式动机。

3. 注意：实时通知不是必要的，但是如果需要实时，优选观察者。

4. 强调的是数据的同步，而非实时的更新

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec06/2.png)

观察者不存数据？只是传过来的副本

* 为何一个一定是抽象类，一个是接口？

利用抽象类可以很好的重用父类的行为。observer派生出两个体系。定义在语言中？

* 一对多：是一个模式下，所以一个观察者可以对应多个观察目标

对象行为型模式：两个对象之间松耦合

为了交互对象之间的松耦合：迪米特法则

* 如何添加新的观察目标（属性）：封装变化
* 通信开销的浪费如何处理：持有subject引用，调用subject的get方法。（push model和pull model）

观察者模式的优点

1. 观察者模式可以**实现表示层和数据逻辑层的分离**，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。
2. 观察者模式在观察目标和观察者之间**建立一个抽象的耦合**。
3. 观察者模式**支持广播通信**。
4. 观察者模式**符合开闭原则**的要求。

观察者模式的缺点

1. 如果一个观察目标对象有很多直接和间接的观察者的话，**将所有的观察者都通知到会花费很多时间**。
2. 如果在观察者和观察目标之间有**循环依赖的话**，观察目标会触发它们之间进行循环调用，**可能导致系统崩溃**。
3. 观察者模式**没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的**，而仅仅只是知道观察目标发生了变化。

观察者变成了语言的一部分

合成复用的优势：java中无法实现。

为何会重载两个版本：对应两个模式，拉模式和推模式。

* 实际的场景中不是发生一点变化就change：写一个钩子方法，决定某些步骤在某些情况下是否执行。从而控制更新的频度。

【重点】：只有一对多才使用观察者。数据集中管理使用观察者

## 模版方法模式

行为型模式，类模式

之前的类模式：工厂方法

动机：希望可以定义

定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法是一种类行为型模式。

主要的实现方法：类继承

* 继承 和 合成的区别，是否有重点：继承是白箱，合成是黑箱。继承应当是复用父类中不经常改动的。合成是复用需要的一些实现。继承可以部分改变父类中的代码。

![img](https://eaglebear2002.github.io/2023Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1-06-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20230609102013766.png)

方法：抽象方法，具体方法，钩子方法

结构图中只有类之间的继承关系，没有对象关联关系。

实现这些具体逻辑步骤的方法称为基本方法（Primitive Method），而将这些基本法方法汇总起来的方法称为模板方法（Template Method）

模版方法一般是被声明为final

钩子方法：控制算法中某些可选的步骤

* 覆盖抽象方法 和 使用钩子控制可选步骤不一样

优缺点：

1. 模板方法模式在一个类中抽象地定义算法，而由它的子类实现细节的处理。
2. 模板方法模式是一种代码复用的基本技术。
3. 模板方法模式导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合“开闭原则”。

每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，但是更加符合“单一职责原则”，使得类的内聚性得以提高。

好莱坞原则：

1. 在模板方法模式中，子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，父类控制对子类的调用，这种机制被称为好莱坞原则（Hollywood Principle），好莱坞原则的定义为：“不要给我们打电话，我们会给你打电话（Don‘t call us, we’ll call you）”。
2. 在模板方法模式中，好莱坞原则体现在：子类不需要调用父类，而通过父类来调用子类，将某些步骤的实现写在子类中，由父类来控制整个过程。

应用：

1. 模板方法模式广泛应用于框架设计（如 Spring，Struts 等）中，以确保父类控制处理流程的逻辑顺序（如框架的初始化）。
2. Java 单元测试工具 JUnit 中的 TestCase 类的设计：
3. 我们只需要提供一些具体的内容，其他不需要操心

扩展：

鼓励恰当的使用继承

* 类模式思想：将实现延迟到子类中

## 适配器模式

动机：通常情况下，**客户端可以通过目标类的接口访问它所提供的服务**。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。

适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。

定义：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器（Wrapper）。

* 适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。

对象适配器：

![img](https://eaglebear2002.github.io/2023Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1-07-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20230609102349666.png)

体现了什么原则：开闭，单一职责，迪米特法则

类适配器：

![img](https://eaglebear2002.github.io/2023Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1-07-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20230609102403121.png)

优点：

1. 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。
2. 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。
3. 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。

类适配器的优缺点

对象适配器的优缺点

应用：

JDBC

提供变化的组件和业务逻辑之间的抽象层

## 组合模式

动机：

1. 对于树形结构，当容器对象（如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，如子文件夹和文件）并调用执行。（递归调用）
2. 由于容器对象和叶子对象在功能上的区别，在使用这些对象的客户端代码中必须**有区别地对待容器对象和叶子对象，而实际上大多数情况下客户端希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂。**
3. 组合模式描述了**如何将容器对象和叶子对象进行递归组合**，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象，这就是组合模式的模式动机。

![img](https://eaglebear2002.github.io/2023Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1-07-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20230609102730137.png)

我们需要递归的结构：类型类似的是之前的宏命令

模式分析：

1. 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。
2. 同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。
3. 文件系统组合模式结构图：

![img](https://eaglebear2002.github.io/2023Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1-07-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/11-1686484548868-983.png)

组合模式的优缺点：

* 透明是以牺牲安全性为代价的

* 安全性的话：只能定义最小接口

希望的是透明性

循环和递归在表达能力上是否有差别？



## 桥接模式

颜色和图形都影响变化：是违反了单一职责原则

用属性其实是一个很好的方法。

通过组合方法组合起来。

某种颜色的行为复用到所有的图形上。

1. 对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系（关联关系比继承关系弱），从而降低了类与类之间的耦合，减少了代码编写量。

定义：桥接模式（Bridge Pattern）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体（Handle and Body）模式或接口（Interface）模式。

重点：抽象化 和实现化 脱耦

约束：至少要有两个变化的维度，【没听到，能否很好的分开成两部分】，是继承关系的替换，感觉是同一个类型中，而非不同的类。

优点：

1. 分离抽象接口及其实现部分。
2. 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。
3. 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。
4. 实现细节对客户透明，可以对用户隐藏实现细节。

缺点：

1. 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。
2. 桥接模式要求**正确识别出系统中两个独立变化的维度**，因此其使用范围具有一定的局限性。

环境：

1. 避免建立静态的继承联系

应用：

1. java虚拟机

* 通过工厂来限制组合关系过于灵活的缺陷。

## 装饰模式

两种方式给类或对象增加行为：继承，关联（组合 && 聚合）

数量不定，类型不定就不能使用属性啦

动机：

装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。

* 静态关系是一个递归关系（类似组合模式）

* 装饰对象和派生对象需要来自同一个类型

定义：

装饰模式（Decorator Pattern）：动态地给一个对象增加一些额外的职责（Responsibility），就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器（Wrapper），与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。

![image-20240411上午112817946](https://github.com/ShadowOnYOU/images/blob/main/test202404111128791.jpg?raw=true)

空递归如何实现 ：小狗图片持有引用为空

装饰者添加和改变：是黑盒的，行为的前后产生影响。而且不方便删除某个具体的装饰者

装饰器模式适合pipeline

继承改变仍然是有效大：对中间行为产生影响

优点：

1. 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。
2. 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。
3. 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。
4. 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合"开闭原则"。

缺点：

1. 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。
2. 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。

环境：

1. 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
2. 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。
3. 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如 final 类）。

模式扩展：

1. 透明
2. 半透明



# 软件架构介绍

每个软件密集型系统都有一个软件设计和体系结构

软件架构师

初始于1960，在1990备受关注

架构在设计阶段的活动

架构设计不是领域知识，而是一种暗知识

注释的生成：读取结构信息；处理需求

AI不能做的：代码审查

两个幸存者：高抽象的设计人员，代码审查人员



## 介绍

软件工程：软件不可见：可变（如果不变化就把它变成硬件了）；

软件工程的四个本质难题：复杂性，一致性（本质上是人的问题），可变型，不可见性



软件架构的定义：

1. “The software architecture of a program or computing system is the structure or structures of the system, which comprise software elements, the externally visible properties of those elements, and the relationships among them.” [Software Engineering Institute (SEl)]
2. “The fundamental organization of a system, embodied in its components, their relationships，to each other and the environment, and the principles governing its design and evolution.” [IEEE 1471 -2000 Recommended Practice for Architectural Description of Software-Intensive Systems"]



component：已经实现的软件部分

module：开发态中一部分

element：两者的集合



工业界的定义：

软件领域的会对后续造成影响的、重要的所有决定都属于架构

element：component connector

relationship：static dynamic relationship



体系结构 && 结构：结构之上的额外定义

component interface

Component communications and dependencies

Component responsibilities

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec12/2.png)

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec12/3.png)

左图：对于结构的描述

右图：加入了AL模块来屏蔽变化

架构设计突出的是你的关注点，可以适当省略一些细节



Communication 包含 data control flow



NFRs：how well a  system works?



Design is an abstraction

Architecture provides an higher level abstract view of a design

blackbox design && white box design



#### Architecture views

体系结构视图主要是为了应对软件不可见问题，屏蔽其他没有影响的部分，将关注点进行分离

#### 4 + 1视图

1. Logical view: describes architecturally significant elements of the architecture and the relationships between them
2. Process view: describes the concurrency and communications elements of an architecture.
3. Physical view: depicts how the major processes and components are mapped on to the applications hardware.
4. Development view: captures the internal organization of the software components as held in e.g./ a configuration management tool.
5. Architecture use cases: capture the requirements for the architecture; related to more than one particular view【场景】

#### Generic design strategies(l六个)

decomposition

abstraction

Stepwise:divid and conquer

Generate and test

iteration

Reusable elements

#### what does a SA do?

1. Liaison:联络人
   1. 在客户、技术团队和商业/需求分析师之间 Among clients, technical team and business/requirements analysts
   2. 包含管理和市场分析 With management or marketing
2. 软件工程：软件工程的最佳实践 Software Engineering:Software engineering best practices
3. 技术知识：深入理解技术领域 Technology Knowledge:Deep understanding of technology domain
4. 风险管理：Risk Management
   1. 与设计、技术决策相关的风险 Risks associated with the design, technology choices
   2. 更多？More?

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec12/4.png)

开发 和 设计是在做减法

#### Architecture activities

1. Creating the business case for the System
2. Understanding the requirements
3. Creating and selecting architecture
4. Communicating the architecture (stakeholders including developers)
5. Analysing or evaluating the architecture
   1. 整体的方法论 Overall methodologies
   2. 具体技术的质量 Quality specific techniques
6. Implementing the architecture
7. Ensuring contormance to an architecture

#### **架构是为了解决那些非常重要的问题**

架构是软件开发的第一个制品

软件架构也是提供了一种沟通的媒介

架构是一个系统的全局设计



架构变更的三种类型：本地（组件属性的变化，或关系的变化，不考虑组件内部的实现变化），非本地（几个组件的变化），架构（修改系统的基本结构，通信和协调机制）

架构是一种**可迁移**和**可重用**的抽象：**一对多映射**(一种架构，许多系统)

架构是产品通用性的基础，整个产品线共享一个架构

CBSE：你需要预测未来的变化（现在从预判式 到 反应式来应对变化）



软件架构过程

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/1.png)

1. 通过StackHolder获取到ASRs(架构攸关的需求)
2. 通过分析得到Prioritized Quality Attribute Scenarios(高优先级质量属性解决方案)和Requirements，Constraints(需求和约束)
3. 将上述部分，结合模式和策略，综合可以得到架构的设计
4. 根据架构的设计得到由模式决定的候选视图的示意图，之后完成文档化
5. 选择、组合视图，将文档进行进一步的评估，这一部分需要StackHolders的参与、也需要Prioritized Quality Attribute Scenarios和文档等作为参考。





# 需求

功能需求

1. 功能性需求定义了**系统必须做什么**并且强调了**系统如何提供价值**给涉众 Functional requirements state what the system must do and address how the system provides value to the stakeholders.
2. 功能性需求意味着**系统的行为** Functional requirements means the behaviour of the system.
3. 功能是系统**完成其预期工作**的能力，例如，使学生能够在线注册。Functionality is the ability of the system to do the work for which it was intended, e.g., enable students to enrol online.
4. 通过使用**许多可能的结构**可以实现功能。Functionality may be achieved through the use of any
   number of possible structures.
5. 功能在很大程度上与结构无关，因为它可以作为单个整体系统存在而没有任何内部结构。Functionality is **largely independent of structure**, because it could exist as a single monolithic system without any internal structure.

质量需求

1. 质量需求是系统应**在其功能要求之上**提供的整个系统的**合乎需要的特性**(又称质量属性) Quality requirements are desirable characteristics of the overall system (aka. quality attrilbutes) that system should provide on the top of its functional requirements.
2. 质量要求是功能要求或整个产品的**资格**。软件体系结构限制了分配 Quality requirements are qualifications of the functional requirements or of the overall product.
3. 如果质量属性很重要，则将**功能**(映射)到各种**结构**上。Software architecture constrains the allocatio (mapping) of the functionality onto various structures if quality attributes are important.

约束

1. 约束是具有**零自由度**的设计决策。A constraint is a design decision with **ZERO** degrees of freedom.
2. 约束是已经做出的**预先**指定的设计决策。Constraints are pre-specified design decisions that have been already made.
3. 通过**接受**设计决策并将其与其他受影响的设计决策进行**协调**，可以满足约束条件。Constraints are satisfied by accepting the design decision and reconciling it with other affected design decisions.



质量属性方案建模：

刺激，刺激源，应对，响应度量，环境，工件（需求适用的整个系统或系统的一部分）

1. 只有定义好这6个元素，就能锁定架构的一个场景，之后可以用来进行架构的设计
2. 刺激和响应发生在一个环境中：系统正常运行、系统过载、系统受到攻击、系统网络等出现了故障。

#### 

战术（原子级别的最小决定）

整个设计是一个层级化的



质量设计决策

七类设计决策：【比较重要的知识点】

1. 职责分配
2. 协调模型
3. 数据模型
4. 资源管理
5. 架构元素之间的映射：将架构元素映射到软件的实现上
6. 绑定时间决策：系统的变化可以在什么时间点前需要固定下来。固定之后就不可以变化了
7. 技术选择



特性：

1. Adaptability
2. Extensibility
3. Availability
4. Modularity
5. Configurability
6. Portability
7. Flexibility
8. Reusability
9. Interoperability
10. Testability
11. Performance
12. Auditability
13. Reliability
14. Maintainability
15. Responsiveness
16. Manageability
17. Recoverability
18. Sustainability
19. Scalability
20. Supportability
21. Stability
22. Usability
23. Security



1. 可用性
   1. 可用性是应用程序的**关键**要求
   2. 度量方式：以**所需**的可用**时间**比例来衡量
      1. ![image-20240423下午33406735](https://github.com/ShadowOnYOU/images/blob/main/test202404231534983.jpg?raw=true)
      2. 可用性策略
      3. ![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/13.png)
      4. detect
         1. 主动发送心跳：Heart Beat
            1. 资源的损耗有一次通讯（定期主动向检测方发送）
            2. 可以同时承担更多的业务(定期更新状态)
            3. 自动化检测，更为定时的服务
            4. 单向更为安全
            5. 一直发送比较频繁。
         2. 被动接受检测：Ping/Echo 或 Minotor（是配合ping echo等使用的）
            1. 资源损耗有两次通讯（代价比较高）
            2. 更加灵活自助，根据自己的情况进行检测
            3. 双向确认
            4. 主动的询问
            5. 偶发性的故障可以考虑这个，没必要长时间的对他进行检测
         3. TimeStamp
            1. 收到一系列的消息应该在时间上有先后顺序
            2. 进行常识的信息的检查，如果和常识不符合那么可能是出现了问题
         4. 自检：检查一下自己是否有问题（可以利用monitor触发自检）
         5. 条件检测：例如年份，不满足正常的范围
         6. 环境检测：网络带宽等（有比较大的风险）
         7. 投票：不一致的意见中找到支持最多的（奇数voter）
            1. 第一种：clone（方法都一样），出现问题就是硬件的问题
            2. 第二种：实现不同的逻辑
            3. 第三种：输入也不同，保证的是结果基本没有问题（用平均值）
      5. 修复：首先要让系统回到一个正常工作的状态
         1. Active Redundancy 冗余部分是都在工作的，如果没有发现问题时，我们**只接受Primary的输入**，而Secondary的输入会被抛弃，有明显的downTime
         2. Passive Redundancy：Primary同步到Secondary（也是online状态，定期与primary同步）上，而如果Primary挂掉了，则启用Secondary，并快速操作(**从上一个状态**)，不一定有明显的DownTime，一般选择使用Passive的方式
         3. Spare：组合在一起使用，secondary offline，重启再加载上一次primary能使用的状态
         4. * 考虑的因素：实现他们的成本，实现的难易程度
         5. 异常处理：如果能处理就在这里处理掉
         6. Rollback：回滚解决不一致的问题
         7. 软件升级：网络上可能有相关补丁了（不停机的，在新的版本下）
         8. Retry
         9. Ignore Faulty Behavior
         10. Degradation：服务降级，比如Windows的安全模式，让目前已经发生的问题不再影响系统的修复
         11. Reconfiguration：
      6. Reintroduction：
         1. shadow：在这段时间内再进行检测，相当于是一个监视期
         2. State Retry Resynchronized
         3. Escalating Restart：扩大重启范围（其他相关组件可能也需要重启）
         4. Non-Stop Forwarding
      7. prevent
         1. removeal from service
         2. transactions:2pc
         3. Predictive model
         4. Exception prevention
         5. Increase competence set

2. 互操作性 interoperability

   1. 互操作性是指两个或多个系统可以在特定上下文中通过接口完全改变有意义的信息的程度 Interoperability is about the degree to which two or more systems can usefully exchange meaningful information via interfaces in a particular context.

      1. **交换**数据的能力(**语法**互操作性)Ability to exchange data (syntactic interoperability)
      2. 能够正确**解释**数据(**语义**互操作性)Ability to correctly interpret the data (semantic interoperability)

   2. 互操作性的两个重要方面：Two important aspects of interoperability:

      1. **发现**：服务的使用者必须发现服务的**位置，身份和接口**。Discovery: the consumer of a service must discover the location, identity, and the interface of the service.

      2. 处理回应

         ：Handling of the response:

         1. 向请求者**报告**并做出**响应**。reports back to the requester with response.
         2. 将其响应**发送**到另一个系统。sends its response on to another system.
         3. 向任何感兴趣的各方**广播**其回复。broadcasts its response to any interested parties.

   3. 策略![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/18.png)

      1. 定位 Locate

         1. 发现

            服务：通过搜索已知目录服务来找到服务Discovery service: locate a service through searching a known directory service.

            1. 多级间接 multiple levels of indirection

      2. 管理界面 Manage interfaces

         1. **编排**：使用控制机制来协调，管理和排序特定服务的调用。Orchestrate: uses a control mechanism to coordinate and manage and sequence the invocation of particular services.
         2. **定制界面**：添加或删除界面功能 Tailor interface: adds or removes capabilities to an interface.

      3. Orchestrate：请求，一个请求会涉及到多个Service，我们需要按照**一定顺序**进行处理请求

   4. ![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/19.png)

   5. ![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/20.png)

3. 可修改性 modifiability

   1. 可修改性涉及**更改**以及进行更改所**花费的时间或金钱**，包括这种可更改性影响其他功能或质量属性的程度。Modifiability deal with change and the cost in time or money of making a change, including the extent to which this modifiability affects other functions or quality attributes.
   2. 为变更做**准备**是有代价的，而**进行**变更则要付出代价。
   3. 四个问题：
      1. 有什么可以改变的？What can change?
      2. 变化的**可能性**是多少？What is the likelihood of the change?
      3. **何时**进行更改，谁进行更改？When is the change made and who makes it?
      4. 变更的**费用**是多少？What is the cost of the change?

   4. 策略
   5. ![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/23.png)
      1. Reduce Size of a Module：**拆分模块**：如果要修改的模块包含**大量功能**，则修改成本可能会很高(尽可能的控制包的大小)。Split module: If the module being modified includes a great deal of capabilities, the modification costs will likely be high.
      2. Increase Cohesion：**增加语义一致性**：如果模块中的职责A和B不能达到**相同的目的**，则应通过创建新模块或将职责移至现有模块将它们放置在不同的模块中。Increase semantic coherence: If the responsibilities A and B in a module do not serve the same purpose, they should be placed in different modules by creating a new module or moving a responsibility to an existing module.
      3. Reduce Coupling：
         1. **封装**为模块引入了显式**接口**，并减少了对一个模块的更改**传播**到其他模块的可能性。Encapsulation introduces an explicit interface to a module, and reduces the probability that a change to one module propagates to other modules.
         2. 使用**中介**打破**依赖**：所有的组件都要通过中间的组件进行通信，使用反模式等方法解决。Use an intermediary breaks a dependency.
         3. 当两个模块受到相同更改的影响时，请进行**重构**：不同于代码重构 Refactor when two modules are affected by the same change.
      4. Defer Binding：**延迟绑定**：在生命周期中与初始定义阶段**不同的阶段**绑定某些参数的值。Defer binding: Binds the value of some parameters at a different phase in the life cycle than the one in which they are initially defined.
   6. checklist：![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/24.png)
   7. ![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/25.png)

4. 



# 性能

性能与时间有关。

响应时间的两个基本因素：处理时间（系统正在响应时），阻塞时间（系统无法响应时）

通用方案：

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/26.png)

time = processing + blocked = demand（= Frequency * ResponsePerEvent） / rate

提高性能即降低时间：少干活，提高速度

需求层面：

1. 降低采样率
2. 限制事件响应
3. 对事件进行优先级排序
4. 使用中介增加处理事件流的资源，减少开销
5. 提升效率：算法等方面

资源层面：

1. 增加资源（more）
2. 如何可以使用并行处理就引入并发
3. 维护多个计算副本，使用负载均衡
4. 维护数据的多个副本
   1. cache等

5. 超过queue的size，发送通知告诉用户暂时无法处理

checklist：

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/29.png)

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/30.png)

## 安全性

保护数据和信息免遭未授权访问的能力，同时提供对授权人员和系统的访问权限

安全性的三个特征（CIA）：

1. 机密性：防止**未经授权**访问数据和服务。
2. 完整性：数据和服务不会受到**未经授权**的操纵。
3. 可用性：系统将可供**合法使用**。

通用方案

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/31.png)

策略：

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/33.png)

prevent：防止由prevent变成一个failure，但是security这边是不希望将attack转变为一个attack

1. 通过将系统内的网络流量或服务请求模式与一组签名或已知模式进行比较来检测**入侵** Detect intrusion by comparing network traffic or service request patterns within a system to a set of signatures or known patterns.
2. 检测服务**拒绝** Detect service denial
3. 使用校验和或哈希值验证**消息的完整性**。Verify message integrity using checksums or hash values.
4. 确定参与者-系统的任何**外部**输入的**来源**。ldentify actors - source of any external input to the system.
5. **验证**演员或他们所要扮演的角色。Authenticate actors who or what they purport to be.
6. **授权**有权访问和修改数据或服务的行为者。
7. **限制**对计算资源的**访问**。Limit access to computing resouces.
8. 通过最小化系统的攻击面来**限制暴露**。
9. **加密**数据。Encrypt data.
10. 正在进行攻击时，撤消对**敏感资源**的访问。
11. Authenticate：认证，Authorize：授权。

checklist

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/34.png)

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/35.png)

## 可测试性

可以使软件通过测试来证明其故障的难易程度。能够把内部的问题暴露出来的能力

策略

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/39.png)

两个角度：内和外

1. 控制和观察系统状态
   1. 能够获知当前状态的能力
   2. 专用界面控制或捕获组件的值
   3. 记录回放导致故障的状态，帮助定位问题
   4. 本地化状态存储
   5. 沙盒将系统实例与现实隔开
2. 限制复杂度
   1. 限制结构的复杂性
   2. 限制不确定性

## 易用性

可用性与用户完成所需任务的**难易程度**以及系统提供的用户**支持**的类型有关。

几个方面：学习系统功能，有效使用系统，最小化错误的影响，使系统适应用户需求，增强信息和满意度

策略：

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/44.png)

1. 支持用户主动权
   1. 取消
   2. 撤销
   3. 暂停/恢复
   4. 对象聚合
2. 初步支持系统
   1. 维护任务模型：预判下一步的操作
   2. 维护用户模型：用户关于系统的知识，根据用户行为训练用户的模型
   3. 维护系统模型：确定预期的系统行为，用于提供适当的反馈



# 架构模式

定义：架构模式是一组架构设计决策，适用于重复出现的设计问题，并进行参数化处理以解决出现该问题的不同软件开发环境。

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/1.png)

## 领域特定的软件体系结构

DSSA是软件组件的组合。

DSSA是最大限度重用知识和进行先期开发并因此开发新的体系结构设计的手段

## 程序设计模式

### 架构模式

架构模式是在实践中反复发现的一套设计决策；具有允许重复使用的已知属性

架构模式建立了以下关系：背景，问题，解决方案（技术和问题的交替中发展出来的）

### 分层模式

对应的是4+1试图中的逻辑视图

**通过分层限制可能的层与层之间的依赖关系**

一个应用：7层协议

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/5.png)

上面的图：假的分层，可以转化成三个独立的模块

下面的图：关键在于D和ABC之间的关系。

层内部高内聚，层之间低耦合（实现的是可修改性的提高）但是分层模式会适当的影响性能。

会影响的质量属性：可修改性，可模块化，可维护性，可复用性

### 代理模式

broker可以理解为中间人，撮合双方达成交易

帮助client找到sercer，并把server的东西传给client

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/7.png)

优点与缺点：

1. 优点：
   1. **根本目的**：是提高server和client之间的交互性（动态的找到所需的服务）
   2. 可伸缩扩展
   3. 可修改性
2. 缺点：（broker容易导致单点失效的情况）
   1. 性能
   2. 安全性
   3. 可用性
3. 两面性：
   1. 性能：整体大集群的性能可能会提高(QPS等提高)，但是局部单点性能会下降，多次网络请求、多次匹配，有可能会抵消。

### MVC模式

放在component-connector里

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/9.png)

### PFP 管道和过滤模式

1. filter：相当于component，起到数据处理、计算作用，每个filter有input和多个output，数据处理后传递给后续的部分。
2. pipe：连接filter，相当于connector，将output导入到其他的filter的input中去，不会孤立存在。
3. 管道和过滤模式不会孤立存在，应用在顺序处理结构，有一系列的数据结构filter，体现依赖关系。
4. 场景应用在科学计算的场景中，需要避免出现环形的filter，不适用于有很多交互产生的场景。

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/11.png)

1. 每一组件表示filter，连接两个组件的部分是pipe(类似于queue交易任务的排队等待处理)
2. 任何一个filter都依赖于前一个filter的输出，中间没有机会接收外部的交互来改变严格定义好的流程。
3. 不适用于一些可以引入变形的场景(相互独立、不依赖前面的产出，会带来损耗)

### CS 客户端-服务端模式

1. 包含两类不同的component
2. 请求发起client、server接收请求，这里没有broker，不能动态改变client和server的关系，相对更固定，但是一个client可以连接多个server
3. 一个component在一个关系中可以是client，也可能是server，非绝对，但是成对的关系相对固定。
4. 会受到负载的限制。
5. Server可能有性能瓶颈，但是可以通过事先规划避免。
6. Server可能单点失效，但是broker可以控制

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/13.png)

### PTP 点对点模式

1. 这一刻是提供者，下一刻就是消费者，是对等的。
2. 不单单提供服务，还能提供物流(对于整个网络)
3. 对每一个peer可能会给他一个规定对的连接数

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/15.png)

1. 可能安全性不受保障，因为节点既是Client又是Server，被攻击可能性提高了，attack、surface受攻击面变大（需要牺牲一定的安全性）
2. 数据分布在不同的节点上，相同数据多处拷贝，如果要的话，可能会导致数据不一致(数据一致性难度更大)，不能保证数据一定可用，数据可用性不能百分之百保证。
3. 可用性 availability，同一个数据多个副本，所以个别数据出问题不影响整体。
4. 但又不能保证availability，不会以后任何一个节点有权限。
5. Performance：多个节点同时提供服务，性能快(多个渠道获取数据，并行能力提高)
6. 可伸缩性：节点加入系统，离开系统都很方便。

### SOA pattern 面向服务的模式

1. broker架构的延续。
2. component包含服务提供者、服务消费者。
3. 除了这些component还有ESB、企业服务组件、连接处理，包括发现、注册。
4. Registry of Services
5. Orchestration Server 不同的Service按照一定的顺序进行编排，提供更高级的(申请贷款流程)
6. Connectors：
   1. SOAP：
   2. REST：
   3. Asynchronous messaging connector
7. 可以访问到不同的组织（），也跨越了技术的边界

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/17.png)

最重要的：互操作性

当然也存在安全，可用性等问题

### 发布-订阅模式

1. subscribe注册对于publiser进行注册
2. 某一个publiser发布自己的消息可能订阅其他消息（朋友圈微博）

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/19.png)

1. 传统操作系统也是通过事件驱动方式来管理的
2. IDE环境注册后就行结构发布的事件
3. 数据发生变化会反映到环境中去
4. 性能上的延迟（可限制subscriber数量订阅越多性能下降）
5. scalability publisher数量不会变多
6. 发布者不关心每个订阅者都收到不是guarantee

### 共享数据模式

中间安全数据会被很多人共享登陆访问

1. 这样一个系统模式有什么问题嘛？
2. 单点失效性能瓶颈问题（都要对它操作） 安全性（攻击中心点有风险）对安全性数据来说强调强一致性如果有副本有一段时间才能到其他副本上更（可能成为漏洞任何时刻访问数据都必须一致）
3. 一致性（重要）
   1. CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）
   2. 看哪个更重要只能同时实现两者
   3. 其他实现一致性方式：最终一致性（不保证任何时候访问数据都一致但是可以保证最终结果要一致） 互联网不可能牺牲可用性也必须是分布式结构（面对分布在很多地方保证信号要求） 一致性设计难度非常大

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/20.png)

星型结构：容易导致单点失效

### Map-Reduced Pattern

属于allocation

1. 软件和外部环境的关系 部署
2. map对数据进行抽取所需要的信息信息转换
3. 可以有多个map 处理数据工作内容不一样
4. 相互独立可以运行
5. reduce进行合并产出想要的答案

1. map reduce部署在不同的地方
2. 词频分析案例大量数据
3. Map-Reduce Based System
4. 每一个partition对应一个map 每一个map任务一样不同实例
5. 所有词汇使用频率标注出来
6. 通过reduce进行合并
7. 最后进行排序

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/23.png)

### 多层模式

1. 部署的环境划分
2. layer是真实存在的
3. 这里是逻辑的组合没有和层的强依赖关系
4. 不同的部署环境里面分层不同但是软件完成内容一样

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/25.png)

## 模式和策略







# ASR

asr是对结构具有长远影响的需求。



MoSCoW：MoSCoW是一种需求优先级分类方法，用于帮助确定项目需求的优先级。它是根据需求的重要性划分为四个类别：Must (必须)、Should (应该)、Could (可以) 和 Won't (不会)。



QAW：



分解：

1. 质量属性需求可以分解，并分配给分解元素。
2. 给定的约束，使得分解之后也能适应那些约束。
3. 设计活动的目标是生成一个适应约束并达到系统质量和业务目标的设计。



非ASR需求如何设计？

1. ASR的选择意味着需求的优先级
   1. 仍然可以满足需求
   2. 稍微修改就可以满足
   3. 无法满足
      1. 即将满足需求
      2. 重新确定需求优先级并重新设计
      3. 不能满足需求



生成并测试

当前设计假设的错误在下一设计假设中得到解决。

下一个假设如何产生？

1. 基于目前的假设，和系统实现的具体情况与质量属性之间的差距
2. 然后结合新的tactics生成下一个假设

实施做出的最佳假设



## ADD 属性驱动设计

1. 步骤（8个步骤）
   1. 确认有足够的需求信息
      1. 需求优先级
      2. 重点关注的系统元素
      3. 刺激反应
   2. 选择要分解的系统元素
      1. 每次选择一个元素作为聚焦点
      2. 标准：哪个element上承载的ASR最多/重要程度最高
   3. 确定所选元素的ASR
      1. 将这个元素的ASR全部取出，并进行排名
      2. 两个维度
         1. 对涉众的重要性
         2. 对体系结构的潜在影响
   4. 选择符合ASR的设计概念
      1. 找出设计问题
      2. 列出替代模式，下属关注的策略
      3. 从清单中选择模式
      4. 确定模式/策略与ASR之间的关系
      5. 捕获初步的架构视图（更细粒度的元素）
      6. 评估并解决不一致问题
   5. 实例化架构元素并分配职责
      1. 实例化选择的元素的实例
      2. 根据子元素类型分配职责
      3. 记录所做的设计决策
   6. 为实例化元素定义接口（元素相互之间的关系）
      1. 接口描述了provides和requires假设
   7. 验证和完善需求，并使其成为实例化元素的约束（整个迭代层面，再做一次test）
      1. 验证分配给父元素的需求是否已分配给一或多个子元素
      2. 将分配给子元素的所有职责转换为各个元素的功能需求
      3. 至此，完成了一个迭代
   8. 重复，直至满足所有ASR（回到第二步）

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec15/2.png)

1. ADD的输出

   1. 软件元素
      1. 履行各种角色和**职责**，具有预定**属性**并与其他软件元素相关以组成系统架构的计算或开发工件
   2. 角色
      1. 一组相关职责
   3. 责任
      1. 软件元素提供的功能，数据或信息
   4. 属性
      1. 有关软件元素的附加信息
   5. 关系
      1. 两个软件元素如何相互管理或交互的定义




1. 步骤1
   1. ![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec15/5.png)
   2. 
2. 选择容错作为设计焦点
   1. 从初始**体系结构要求**中识别出**7**个ASR
   2. 从ADD的第一次迭代产生的**设计约束**中识别出**3**个ASR
3. 选择设计
   1. 具体的一些设计问题
      1. 四个分支就是4个关注点
      2. 设计考量
   2. 为何不选择prevent faults：因为当前的设计焦点是容错，是考虑系统的容错。Prevent Faults通常是系统级别的策略，而这里的容错，设计核心为TrackManager这一元素
   3. 列出前面设计考量的一些具体策略
4. 做一个选择
   1. 先选一个，但是要在后面进行验证，或许还要重新进行调整



# 微服务架构

## 微服务架构基础

单体架构 ----- 分层架构 ------- SOA架构 ------ 微服务架构

单体：all in one



分层：虽然分了，但是在业务层次内部随着需求的增加，内部也会变成一个臃肿的小单体

微服务架构：小 而 自治

Devops和微服务相辅相成





拆分

核心是第二步



## 文件架构

### 为何需要记录架构

1. 交流和社交化架构设计决策
2. 帮助理解和评估架构设计决策
3. 刷新设计师对某些决策的记忆 
4. 培训架构设计人员
5. 支持地理位置分散的团队

体系结构文档应用的活动：1. 架构设计分析2. 工作分解和分配 3. 部署后维护

软件体系结构文档提供了维护和修改决策的框架

### 记录架构的挑战

1. **没有**普遍接受的记录软件架构的**标准**或方法
2. 记录大型系统的架构可能是一项**耗时**且重要的任务
3. 对用于记录架构的视图的**数量和性质没有达成共识** - 资源密集型活动。
4. 迫在眉睫的最后期限和不断发展的架构性质不利于架构文档的流通
5. 缺乏全面的**符号和工具**

### 我们需要记录些什么

1. 组件**接口**和**依赖项**
2. 子系统**约束** （有些子系统可能是外包的或者开源的）
3. **测试场景**（主要是非功能的测试，来源是质量属性）
4. 围绕设计决策的**上下文**信息

影响的因素：

1. 被记录的架构的**复杂性**
2. 应用程序的**寿命**
3. 基于**涉众**对文档的预期使用

### (7) Rules for Architecture Documentation

1. 从**读者的角度**撰写文档 Write documentation from the reader’s point of view
2. 避免没有意义的**重复** Avoid unnecessary repetition.
3. 避免**模糊性** Avoid ambiguity.
4. 使用**标准**的文档组织方式 Use a standard organization.
5. 记录**理由** Record rationale.（该设计决定是如何与之前的ASR建立联系）
6. 保持文档**最新**但不要太最新 Keep documentation current but not too current（不要按照软件更新的这个版本，太快了）
7. **审查**文件是否适合**用途** Review documentation for fitness of purpose

## 视图和视图之外的部分

### 视图风格

1. 它是如何构建为一组实现单元的？How it is structured as a set of implementation units? Module styles（静态的，结构化的，生命周期内不怎么发生变化的）
2. 它是如何构建为一组具有运行时行为和交互的元素的？How it is structured as a set of elements that have runtime behavior and interactions? Component-connector(C&C) styles（动态的）
3. 它与环境中的非软件结构有何关系？How it relates to non-software structures in its environment? Allocation style（软件和软件外的）

style vs patterns

1. 架构模式的一个重要部分是关注问题和上下文，以及如何在该上下文中解决问题。
2. 架构风格侧重于架构方法，对特定风格何时有用或无用提供更轻量级的指导。
3. 架构模式：{问题，上下文} --> 架构方法
4. 架构风格：架构方式
5. 风格描述通常不包括详细的问题/上下文信息； 架构模式可以。
6. 微服务知识定义了element，和element通过什么方式进行交互。

### 架构视图

1. 视图是一组系统元素和它们之间关系的表示——不是所有的系统元素，而是特定类型的那些元素
2. 视图让我们将系统的实体划分为有趣且易于管理的系统表示
3. 不同的视图支持不同的目标和用户，突出不同的系统元素和关系
4. 不同的视图在不同程度上暴露了不同的质量属性

### 结构关系视图

#### 模块视图

1. 模块是提供一组连贯职责的实现单元
2. 没有**至少一个模块视图**，任何软件架构的文档都不可能是完整的
3. 视图示例
   1. 分解视图 Decomposition view
   2. 使用视图 Uses view
   3. 泛化视图 Generalization view
   4. 分层视图 Layered view
   5. 领域视图 Aspects View
   6. 数据模型视图 Data model view

### 质量视图

1. 安全视图 Security view
2. 性能视图 Performance view
3. 可靠性视图 Reliability view
4. 沟通视图 Communication View
5. 异常(错误处理)视图Exception view (error-handling) view

### 文档视图

#### 使用3步选择视图 3-Step for Choosing Views

1. 步骤 1：构建**涉众/视图表** Step-1: Build a stakeholder/view table
2. 步骤 2：合并视图Step-2: Combine views
   1. 2.1 识别上表中的边缘视图 2.1 Identify marginal views in the above table
   2. 2.2 通过关联一个视图中的元素和另一个视图中的元素，将每个边缘视图与另一个具有更强选区的视图相结合 2.2 Combine each marginal views with another view with stronger constituency by associating between elements in one view and elements in the other
3. 步骤 3：确定优先级和阶段 Step-3: Prioritize and stage
   1. 分解视图 decomposition view
   2. 80/20原则 80/20 principle
   3. 按顺序完成所有视图？complete all views in sequence?

#### 利益相关者视图表

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec17/6.png)

- 上图中每一个格子是指涉众对某一个部分的细节了解程度。
- 可以考虑舍弃或合并

### 合并视图

### 上下文视图



### 超越

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec17/11.png)



# 评估框架

## 1. 框架过程

### 为何需要评估架构

1. 大型项目经常延迟交付和超出预算
2. 项目后期需要大量的返工
3. 架构评估有助于缓解这些问题
4. 在问题修复代价还比较低时尽早定位问题
   1. 设计缺陷
   2. 没有考虑到的商业组件行为
5. 传播架构/设计最佳实践
6. 提供更好的技术和项目信息给管理层
7. 确定培训可以对常见问题领域产生广泛影响的领域
8. 改善与商业组件供应商的互动

### 何时需要评估架构

1. 基本原则：越早越好
2. 期望获得
3. 演化/升级
4. 设计【主要还是这边】
5. 构建
   1. 这时候就可以进行真正的test

### 为何要在早期进行架构评估

1. 要尽早完成因为
   1. 还有时间来修复
   2. 修复错误的决定的成本相对比较小
   3. 它是最有效的质量保证和风险缓解技术之一
   4. 这被认为是一种良好的商业惯例
2. 早期质量评估具有成本效益
3. 存在相互竞争的需求
   1. 需要作出选择
   2. 
4. 架构设计决策的基本原理应该被捕获和推理

### 如何评估软件架构

### 方法如何变得有用

1. 帮助涉众尽早问正确的问题
2. 发现趋势：架构决策与系统属性预测之间的相关性
3. 可以通过进一步分析、设计或原型制作来减轻风险
4. 所做的权衡和支持它们的理由可以适当地记录下来以备将来参考

### 评价分析方法

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec18/2.png)

经验：偏差较大

对系统进行粗略的分割：BOTE

头脑实验：TE

checklist：

例如状态机等：A M（往往是静态的关系）

仿真：随时间的变化表现

原型：部分实现的模型

实验：把一些测试作为实验

最佳实践：真实环境中进行运行



### 评估格式

1. **设计师**在设计过程中评估
   1. 生成-测试方法
2. 其他人评估
3. 架构设计完成后由外部人员进行评估

## ATAM：架构权衡分析方法

### 阶段

分为四个阶段

0. 准备 && 伙伴【还没开始评估，只是做准备】
   1. 参与者
   2. 输入：架构设计文档
   3. 输出：评估计划
1. 评估
   1. 参与者：评估团队和项目决策者
   2. 步骤1-6
   3. 输出：
2. 评估
   1. 参与者：评估团队，项目决策者和架构涉众
   2. 7-9
   3. 输出
3. 后续



### 步骤

1. 介绍ATAM

   1. 评估负责人向集合的项目代表（“决策者”）简要介绍 ATAM，让他们了解评估的过程和输出 

2. 介绍业务驱动因素

   1. 项目经理或系统的客户从业务角度呈现系统概览，描述 Project
      1. 功能需求
      2. 技术、管理、经济等限制
      3. 商业目标和上下文
      4. 主要涉众
      5. 架构驱动因素

3. 介绍架构

   1. 首席架构师在适当的细节级别上进行了描述架构的演示
      1. 技术限制，例如规定使用的操作系统、硬件或中间件
      2. 系统必须与之交互的其他系统
      3. 用于满足质量属性要求的架构方法
   2. 架构演示
      1. 推动架构要求、与这些要求相关联的可测量数量，以及满足这些要求的任何现有标准/模型/方法

4. 确定架构方法

   1. ATAM 专注于通过理解架构方法来分析架构
   2. 在这一步，评估团队
      1. 研究了架构文档
      2. 听取了架构师的展示
      3. 向架构师询问了设计系统时使用的模式和策略
   3. 评估团队对已确定的架构方法（风格、模式和策略）进行编目

5. 生成质量属性效用树

   1. 是指导其余分析的关键步骤
   2. 评估团队与项目决策者合作，确定、确定和优化系统最重要的质量属性目标。
   3. 质量属性目标通过质量属性效用树详细阐述，该树通过精确定义相关质量属性需求使需求具体化

   ![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec18/4.png)

6. 分析架构方法

   1. 找到对应关系

![image-20240604下午32940293](https://github.com/ShadowOnYOU/images/blob/main/test202406041529168.jpg?raw=true)

### 第二阶段

6. 展示ATAM和之前的结果

7. 头脑风暴并确定场景的优先级

8. 分析架构方法 

9. 展示结果
   1. 1 4
   2. 2
   3. 1 5
   4. 1 & 2

### 输出总结

1. 架构的简明展示 A concise presentation of the architecture
2. 业务目标的阐述 Articulation of the business goals
3. 表示为质量属性场景的优先质量属性要求 Prioritized quality attribute requirements expressed as quality attribute scenarios
4. 引用树 A utility tree
5. 一组风险和非风险 A set of risks and nonrisks
6. 一组风险主题 A set of riskthemes
7. 将架构决策映射到质量要求 Mapping of architectural decisions to quality requirements
8. 一组确定的敏感度和权衡点 A set of identified sensitivity and tradeoff points
9. 最终的评估报告 Final evaluation report

### Lightweight architecture evaluation

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec18/8.png)

## 外观模式

外部与子系统的通信必须通过一个同意的外观对象进行

迪米特法则























































