---
layout: post
title: 嵌入式系统
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 嵌入式系统——实时调度

## 1. 实时系统所需的调度策略

任务集合需要调度策略

1. 优先级约束
2. 时间约束

### 调度程序

调度程序决定接下来执行哪个任务

多处理器调度：下一步执行哪个任务，由哪个处理器来执行

#### 分类

1. 根据决策制定的时间
   1. 完全静态调度程序（在系统设计时制定三项决策）
      1. 难以实现，因为执行时间难以预测，且具有数据依赖性
   2. 静态调度程序/离线调度程序（在设计时完成任务的分配和排序，直到任务运行时才确定每个任务的物理执行时间）
      1. 不会根据一个信号或者互斥锁的状态改变任务的顺序
   3. 在线调度程序
      1. 静态分配调度（设计时制定任务的分配）
      2. 完全动态调度（在任务运行时制定所有的决策）

#### 任务模型

![截屏2023-11-20 上午10.51.25](https://github.com/ShadowOnYOU/images/blob/main/test202311201051557.png?raw=true)

#### 任务的周期

![截屏2023-11-20 上午10.53.07](https://github.com/ShadowOnYOU/images/blob/main/test202311201053959.png?raw=true)

#### 任务执行的相关时间

![截屏2023-11-20 上午10.54.40](https://github.com/ShadowOnYOU/images/blob/main/test202311201054711.png?raw=true)

时限：截止时限

##### 时限约束

若进程没有在截止时限前完成会发生什么？

1. 硬截止时限：若错过，系统将失败
2. 软截止时限：反应不需要严格执行的设计策略，最好满足时限要求，但是错过了也不算错误
   1. 也许会试图采取一些补偿型的措施

#### 优先级

每个任务都有优先级号，调度程序总是线执行优先级高的任务（通常用最小的优先级号表示）

固定优先级，动态优先级

抢占式调度与非抢占式调度程序

### 调度决策：

分配：应该由哪个处理器执行任务

排序：每个处理器按什么顺序执行相应任务

定时：每一项任务什么时候执行

### 调度程序的度量

1. 可行调度
   1. 可行调度是指在给定的限制条件下，为任务或作业分配资源和时间，使得任务能够在约束下成功完成的调度方案。
2. CPU利用率
   1. 指处理器用于执行任务时间（对闲置时间）的百分比
3. 调度开销
4. 延迟
   1. 完成时间剪去减去时限
   2. 值为0或负数（可行调度）
   3. 软实时，可以容许最大延迟值为正数
5. 总完成时间/总时程
   1. 性能指标不是实时要求
   2. 是指完成一个项目或任务所需的总时间，从开始到结束的整个时间跨度。

### 嵌入式调度 && 通用调度

通用：试图避免进程饿死（公平性=对CPU的访问）

嵌入式：必须满足截止期限（低优先级的进程可能被饿死）

### 调度程序何时被调用

非抢占式 + 抢占式

#### 单调速率调度 RMS（它真的很简单）

![截屏2023-11-20 上午11.36.36](https://github.com/ShadowOnYOU/images/blob/main/test202311201136474.png?raw=true)

##### RMS的缺点

CPU利用率偏低

##### RMS的优点

单处理器系统中最优的固定优先级抢占式调度算法

##### 临界时刻定理：很多实时系统都用到了

对于固定优先级调 度，如果任务T1与所有更⾼优先级 的任务同时释放，那么，每个任务 在单处理器系统上执⾏的响应时间 就是最⼤化的

### Jackson算法（EDD）

一只一个有限非重复任务集，截止时限克制，无优先序约束（任务之间独立），调度使其最大延迟最小化

![截屏2023-11-27 上午10.18.58](https://github.com/ShadowOnYOU/images/blob/main/test202311271019009.png?raw=true)

#### 最大延迟最小化

EDD在最小化最大延迟方面是最优的

![截屏2023-11-27 上午10.23.36](https://github.com/ShadowOnYOU/images/blob/main/test202311271023308.png?raw=true)

上部：非EDD，下部：EDD

### Hoen算法（EDF）

最早截止时限有限

EDD不支持任务到达，可以通过允许任务在任何时刻到达

EDF：给定n个具有任意到达时间的独立任务集，在任何时刻，在所有到达的任务中执行绝对**截止时限最早**的任务的算法对于最大延迟最小化是最优的

适用于周期性任务与非周期性任务

红线：任务的截止时限

![截屏2023-11-27 上午10.32.19](https://github.com/ShadowOnYOU/images/blob/main/test202311271032484.png?raw=true)

图的理解：就是比较红线的远近（注意不是固定的数值，看图）

### EDF && RMS

![截屏2023-11-27 上午10.37.10](https://github.com/ShadowOnYOU/images/blob/main/test202311271037900.png?raw=true)

![截屏2023-11-27 上午10.42.26](https://github.com/ShadowOnYOU/images/blob/main/test202311271042509.png?raw=true)

时间的比较：首先是1，然后2和3比，然后2和6比。（这不是可行调度，4超了）

### 最晚时限优先

在优先序约束下，LDF时最优的

反向的过程，刚才是从左向右。（先比较456，确定6最后执行，然后比较345，取5）

![截屏2023-11-27 上午10.47.20](https://github.com/ShadowOnYOU/images/blob/main/test202311271047174.png?raw=true)

在最大延迟最小化方面是最优的，不需要抢占，不支持动态到达，所有任务已知且在执行任何任务之前都知道它们的优先序约束

### EDF*

其实思想就是修正

![截屏2023-11-27 上午10.49.43](https://github.com/ShadowOnYOU/images/blob/main/test202311271049201.png?raw=true)

![截屏2023-11-27 上午10.50.04](https://github.com/ShadowOnYOU/images/blob/main/test202311271050571.png?raw=true)

1. 任务的释放时间（Release Time）：任务的释放时间是指任务可用于执行的时间点或时刻。它表示任务从任务生成者处产生或发布的时间，也可以理解为任务进入系统可调度状态的时间点。任务的释放时间通常与任务调度相关，指示任务何时可以开始执行。
2. 任务的执行时间（Execution Time）：任务的执行时间是指任务实际执行所需的时间。它表示任务从开始执行到完成所花费的时间。任务的执行时间可以是实际的处理时间，也可以是任务在系统中占用处理资源的时间。

进行修改：截止时限（从右向左）。释放时间（从左向右）

![截屏2023-11-27 上午10.57.41](https://github.com/ShadowOnYOU/images/blob/main/test202311271057780.png?raw=true)

![截屏2023-11-27 上午10.58.04](https://github.com/ShadowOnYOU/images/blob/main/test202311271058473.png?raw=true)

### 如果不可调度该如何

若进程组不可调度，又需要保证在截止时限之前完成

1. 使用更快的CPU
2. 重新设计进程一减少执行时间
3. 重写规格说明改变截止时限
