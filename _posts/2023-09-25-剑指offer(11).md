---
layout: post
title: 剑指offer(11)——简单+中等
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 剑指offer(11)——简单+中等

## 题目144:

给定一棵二叉树的根节点，请左右翻转这棵二叉树，并返回其根节点。

**示例 1：**

![img](https://pic.leetcode.cn/1694686821-qlvjod-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png)

```
输入：root = [5,7,9,8,3,2,4]
输出：[5,9,7,4,2,3,8]
```

### 我的代码

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        TreeNode* node = new TreeNode(0);
        if(root == nullptr){
            return root;
        }
        node->val = root->val;
        if(root->right != nullptr){
            node->left = mirrorTree(root->right);
        }
        if(root->left != nullptr){
            node->right = mirrorTree(root->left);
        }
        return node;
    }
};
```

思路简单的总结一下就是利用递归进行思考

### 解题方法1:更简单的递归方法

```c++
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if (root == nullptr) return nullptr;
        TreeNode* tmp = root->left;
        root->left = mirrorTree(root->right);
        root->right = mirrorTree(tmp);
        return root;
    }
};
```

### 解题方法2:辅助栈或队列

```c++
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(root == nullptr) return nullptr;
        stack<TreeNode*> stack;
        stack.push(root);
        while (!stack.empty())
        {
            TreeNode* node = stack.top();
            stack.pop();
            if (node->left != nullptr) stack.push(node->left);
            if (node->right != nullptr) stack.push(node->right);
            TreeNode* tmp = node->left;
            node->left = node->right;
            node->right = tmp;
        }
        return root;
    }
};
```

## 题目145:

请设计一个函数判断一棵二叉树是否 **轴对称** 。

**示例 1：**

![img](https://pic.leetcode.cn/1694689008-JaaRdV-%E8%BD%B4%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%911.png)

```
输入：root = [6,7,7,8,9,9,8]
输出：true
解释：从图中可看出树是轴对称的。
```

**示例 2：**

![img](https://pic.leetcode.cn/1694689054-vENzHe-%E8%BD%B4%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%912.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
解释：从图中可看出最后一层的节点不对称。
```

**提示：**

```
0 <= 节点个数 <= 1000
```

### 我的代码

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool checkSymmetricTree(TreeNode* root) {
        TreeNode* reverse = mirrorTree(root);
        if(root == nullptr){
            return true;
        }
        if(isSame(root, reverse)){
            return true;
        }
        return false;
    }
    TreeNode* mirrorTree(TreeNode* root) {
        TreeNode* node = new TreeNode(0);
        if(root == nullptr){
            return root;
        }
        node->val = root->val;
        if(root->right != nullptr){
            node->left = mirrorTree(root->right);
        }
        if(root->left != nullptr){
            node->right = mirrorTree(root->left);
        }
        return node;
    }
    bool isSame(TreeNode * a, TreeNode * b){
        if(a == nullptr && b == nullptr){
            return true;
        }
        if(a == nullptr) return false;
        if(b == nullptr) return true;
        if(a->val == b->val){
            return isSame(a->left,b->left) && isSame(a->right, b->right);
        }
        return false;
    }
};
```

我的方法比较愚蠢，就是将这个树翻转一下，然后看前后的两棵树是不是相同的。

### 解题方法1:递归

```c++
class Solution {
public:
    bool check(TreeNode *p, TreeNode *q) {
        if (!p && !q) return true;
        if (!p || !q) return false;
        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);
    }

    bool checkSymmetricTree(TreeNode* root) {
        return check(root, root);
    }
};
```

！递归还是需要学习的，对递归的理解还不够深入

