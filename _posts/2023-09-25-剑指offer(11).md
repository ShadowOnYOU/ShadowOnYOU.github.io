---
layout: post
title: 剑指offer(11)——简单+中等
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 剑指offer(11)——简单+中等

![截屏2023-10-25 17.14.38](https://github.com/ShadowOnYOU/images/blob/main/test202310251714094.png?raw=true)

![截屏2023-10-25 17.15.08](https://github.com/ShadowOnYOU/images/blob/main/test202310251715160.png?raw=true)

![截屏2023-10-25 17.15.42](https://github.com/ShadowOnYOU/images/blob/main/test202310251715476.png?raw=true)

![截屏2023-10-25 17.16.58](https://github.com/ShadowOnYOU/images/blob/main/test202310251717484.png?raw=true)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
解释：从图中可看出最后一层的节点不对称。
```

**提示：**

```
0 <= 节点个数 <= 1000
```

### 我的代码

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 class Solution {
 public:
    bool checkSymmetricTree(TreeNode* root) {
        TreeNode* reverse = mirrorTree(root);
        if(root == nullptr){
            return true;
        }
        if(isSame(root, reverse)){
            return true;
        }
        return false;
    }
    TreeNode* mirrorTree(TreeNode* root) {
        TreeNode* node = new TreeNode(0);
        if(root == nullptr){
            return root;
        }
        node->val = root->val;
        if(root->right != nullptr){
            node->left = mirrorTree(root->right);
        }
        if(root->left != nullptr){
            node->right = mirrorTree(root->left);
        }
        return node;
    }
    bool isSame(TreeNode * a, TreeNode * b){
        if(a == nullptr && b == nullptr){
            return true;
        }
        if(a == nullptr) return false;
        if(b == nullptr) return true;
        if(a->val == b->val){
            return isSame(a->left,b->left) && isSame(a->right, b->right);
        }
        return false;
    }
 };

我的方法比较愚蠢，就是将这个树翻转一下，然后看前后的两棵树是不是相同的。

### 解题方法1:递归

class Solution {
public:
    bool check(TreeNode *p, TreeNode *q) {
        if (!p && !q) return true;
        if (!p || !q) return false;
        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);
    }

bool checkSymmetricTree(TreeNode* root) {
    return check(root, root);
}

};

！递归还是需要学习的，对递归的理解还不够深入

![截屏2023-10-25 17.18.16](https://github.com/ShadowOnYOU/images/blob/main/test202310251718511.png?raw=true)

### 解题方法1:回溯

![image-20230925193802544](https://github.com/ShadowOnYOU/images/blob/main/test202309251938048.png?raw=true)

class Solution {
public:
    bool exist(vector<vector<char>>& grid, vector<vector<int>>& visited, int i, int j, string& s, int k) {
        if (grid[i][j] != s[k]) {
            return false;
        } else if (k == s.length() - 1) {
            return true;
        }
        visited[i][j] = true;
        vector<pair<int, int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        bool result = false;
        for (const auto& dir: directions) {
            int newi = i + dir.first, newj = j + dir.second;
          // 这边我觉得很厉害，我们在使用时可以直接限定一下得到有效的位置
            if (newi >= 0 && newi < grid.size() && newj >= 0 && newj < grid[0].size()) {
                if (!visited[newi][newj]) {
                    bool flag = exist(grid, visited, newi, newj, s, k + 1);
                    if (flag) {
                        result = true;
                        break;
                    }
                }
            }
        }
        visited[i][j] = false;
        return result;
    }

bool wordPuzzle(vector<vector<char>>& grid, string word) {
    int h = grid.size(), w = grid[0].size();
    vector<vector<int>> visited(h, vector<int>(w)); // 这边初始化的方式可以学习一下
    for (int i = 0; i < h; i++) {
        for (int j = 0; j < w; j++) {
            bool flag = exist(grid, visited, i, j, word, 0);
            if (flag) {
                return true;
            }
        }
    }
    return false;
}

};

