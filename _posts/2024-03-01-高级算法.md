---
layout: post
title: 操作系统设计与实现
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 操作系统设计与实现

7 实验作业 3 期末作业

什么是操作系统：程序，用户与硬件之间的媒介

为何现在我们不需要额外安装驱动：现在都已经预装了

第三方的驱动程序：也是很重要的

操作系统作用：资源的管理，提供抽象和封装，



如何实现操作系统？



系统会不断的迭代升级



我们的操作系统主要还是基于c，c++



抽象 与 虚拟

将外设抽象为一个虚拟的文件

进程：



复用和保护

复用：时分和空分的复用

保护；防止应用程序间的干扰，保证运行独立性



拆分：

功能：资源管理，控制执行，提供接口

目标：便于使用，提升机器能力，提高运行效率（操作系统 && 运行的程序），提供开放环境（一定的通用性和可扩展性）



操作系统的主要特性（我们的挑战）：并发性（两个或两个以上的时间在同一时间间隔内发生，注意与并行性的区别），共享性，异步性

![截屏2024-03-01 下午7.36.03](https://github.com/ShadowOnYOU/images/blob/main/test202403011936323.png?raw=true)



BIOS ROM：原本是出厂就写死

BIOS是计算机开机执行的第一条指令

做的事情：自检，从磁盘第0

MBR：主引导扇区，存放了Bootloader（把真正的操作系统加载到内存中，把控制权交给OS）



QEMU：模拟计算机硬件

我们make得到一个os.img

磁盘的第0扇区是MBR，第1-255扇区中放kernel，再后面就是用户程序文件



保护模式

GDT：全局向量表

段选择子

补全GDT中的内容

关注点：基地址，base全部设成0



ELF文件：可执行目标文件

对内核的ELF文件打交道

加载操作系统 = 将OS kernel对应的elf文件装载到内存并运行

预处理会将define进行替换，得到.i文件；之后进行编译，得到汇编文件.s文件。在经过汇编和连接

e_entry

![image-20240301下午81600282](https://github.com/ShadowOnYOU/images/blob/main/test202403012016325.jpg?raw=true)

test.h定义一个函数，并在test.c中得到了实现

只要关注前三个部分

段：代码段

遍历程序头表，一个重要的属性是 P_type == pt_load,否则不需要移动到内存中，直接跳过即可

p_offset也是一个偏移量。帮助我们从ELF头定位到段的地址

p_vaddr

p_paddr







# class 2

内存管理初步

内存：程序的指令和数据被保存在存储器（主存）中，供运算部件或控制器件使用

层次化存储：实现虚拟和抽象，保护存储的内容



如何管理缓存：

CPU获取数据时会先查缓存，缓存缺失时会通过总线访问内存。



连续的内存空间管理

分类：单用户，固定分区，可变分区



单分区模式：物理地址 = 界限地址 + 逻辑地址（内存空间划分为系统区和用户区）

固定分区：静态分区，给进入内存的用户程序划分一块连续的存储区域，若有多个道程序被装入，课同时执行

​	实现：系统初始时，把可分配的内存空间分割成若干个连续的区域（把内存分割成固定的大小）

​	缺点：无法预知分区的大小，主存的空间利用率较低，无法适应动态扩充主存，分区数量限定了同时运行的程序数

可变分区：由“已分配区表”和“未分配区表”组成

​	可变分区的回收：合并。

​	存在的问题：要求占用的是连续的存储空间，经过一段时间的使用还是会造成内存碎片



地址转换：逻辑地址转化成物理地址

存储保护

防止操作系统和各用户程序内存中各存储区域访问时相互干扰



分页式存储管理

如何应对内存不足的连续存储：移动（移走以实现一个连续地址），覆盖（），交换（）

定义：允许程序存放在若干不相邻的分区中，可以免去移动内存信息而产生的工作量，又可以减少内存碎片的产生

页框：把内存空间按物理地址分成多个大小相等区，每个区又被称为块

页面：对于程序按照逻辑地址进行分区

物理地址 = 页框号 * 块长 + 单元号

逻辑地址 = 页号 * 页长 + 单元号

页号 和 页框号 的转换通过内存的页表

* 上述过程会导致两次的内存访问

所以我们有cache，用于存放最近被访问的部分页表

页面共享和保护：通过标志位进行内容保护



![image-20240308下午75814915](https://github.com/ShadowOnYOU/images/blob/main/test202403081958498.jpg?raw=true)



什么是elf文件？

预处理就是展开头文件，进行宏文件的替换

编译：转化成二进制机器指令

链接：



根据task2进行整理：

# Class 3

处理器管理初步

程序的指令由处理器执行，数据由处理器进行运算

处理器管理是重要部分，负责管理、调度和分配计算机系统的重要资源——处理器，并控制程序执行

如何管理处理器？

用户进程切换到系统进程？会发生什么事情

对处理器的管理是通过控制程序执行，对程序的调度来实现（系统程序之间，系统程序和用户程序，用户程序之间）

涉及的主要内容：处理器（资源）分配，运行的程序（进程）调度



中断机制



特权指令的执行权限，使处理器必须能区分当前运行的程序是操作系统还是普通应用程序

中断处理需要硬件（中断装置）和软件（中断处理程序）合作完成



有关实验

1. 保护断点 和 程序状态
2. 关中断
3. 识别异常和中断时间并转到响应的处理程序执行

实模式 && 保护模式



1. 准备阶段
2. 处理阶段
3. 恢复阶段







