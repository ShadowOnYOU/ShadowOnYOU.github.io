---
layout: post
title: 移动互联网复习资料
categories: [移动互联网]
description: some word here
keywords: 移动互联网, 鸿蒙开发
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 移动互联网复习（2）

## 第7章 SWEBOK

### 1. SWEBOK中的新增点 && 重点

新增：软件结构，软件工程运作，软件安全

重点：软件工程模型和方法，计算基础，工程基础

![截屏2023-12-08 下午2.29.36](https://github.com/ShadowOnYOU/images/blob/main/test202312081429235.png?raw=ture)

![截屏2023-12-08 下午2.30.00](https://github.com/ShadowOnYOU/images/blob/main/test202312081430139.png?raw=true)

![截屏2023-12-08 下午2.30.28](https://github.com/ShadowOnYOU/images/blob/main/test202312081430882.png?raw=true)

### 2. 计算基础

#### 1. 系统或解决方案的基本概念

工程系统确保子系统的设计符合要求：模块化（每个子系统都是统一的（大小相似））；内聚性（每个子系统执行一项特定任务，理想状态下系统具有高内聚性）；耦合（每个子系统尽可能独立运行，理想状态下系统应该是松耦合的）

#### 2. 数据结构和算法

##### 数据结构类型

数据类型是数据的一种属性。各种数据类型是根据数据的不同特征，对数据项进行分组的需要以及对数据执行的各种操作来确定和定义的。

三类：基本数据，复合数据（集合，图形等），抽象数据（从用户角度，从可能的只和操作的角度定义行为（语义））

##### 设计算法

![截屏2023-12-08 下午2.38.11](https://github.com/ShadowOnYOU/images/blob/main/test202312081438919.png?raw=true)

分拣技术 + 搜索技术 + 散列技术

##### 编程基础和语言

以其名称作为返回值的子程序称为函数，不反悔任何值的子程序称为过程

##### 分布式编程 && 并行编程

| 分布式编程 | 并行编程                                           |                                                |
| :--------- | :------------------------------------------------- | ---------------------------------------------- |
| 定义       | 在多台计算机或计算节点上开发应用程序，通过网络通信 | 在单个计算机或计算节点上同时执行多个任务或操作 |
| 目标       | 提高性能、可伸缩性和容错性                         | 提高计算速度和系统吞吐量                       |
| 资源组织   | 多台计算机或计算节点，可能具有独立的内存和存储     | 单个计算机或计算节点，共享内存和存储           |
| 通信方式   | 通过网络进行通信和协调                             | 通过共享内存或消息传递进行通信和协调           |
| 任务分解   | 将工作负载分布到不同计算资源上的任务               | 将任务分解为并行执行的子任务                   |
| 应用场景   | 大规模系统、分布式数据库、分布式计算等             | 并行计算、高性能计算、多线程编程等             |

##### 调试

语法错误，运行错误，逻辑错误

##### 学习

监督学习，无监督学习，半监督学习，强化学习

##### 模型

线性回归，逻辑回归，人工神经网络，决策树，直觉贝叶斯，支持向量机，随机森林

##### 自然语言处理

NLP。能让用户与人工智能系统进行类似于人机交互的互动。

##### 人工智能 与 软件工程

AI for SE && SE for AI

面向SE的AI几乎涵盖所有开发阶段，从解决模棱两可的需求到预测可维护性，尤其适用于软件质量保证和分析，缺陷预测，测试用例生成，漏洞分析和流程评估。但工程师也要意识到AI和ML本身的局限性，尤其是不确定性和随机行为

为AI的SE提供人的帮助

### 3. 工程基础

#### 工程设计

软件的设计要以时限的功能和要达到的质量属性为指导。

可能的解决方案往往收到明确施加的限制，如成本、可用资源以及学科和领域知识的限制。在工程问题中，优势也存在隐含的限制（材料的物理特性或物理定律）

#### 抽象与封装

抽象是解决问题不可或缺的技巧。通过减少概念、问题域或可观察现象的信息。

通过抽象画，可以从更高的概念理解层面来看待问题以及其可能的解决途径

封装是一种用于实现抽象的机制。

层次结构：当我们在指定和解决问题的过程中使用抽象概念时，我们可能会在不同的时间使用不同的抽象概念。换句话说，我们会根据情况的需要使用不同层次的抽象方法。

#### 建模，模拟和原型开发

建模是抽象过程的一部分，用于表示系统的某些方面

模拟是使用一个系统模型，并提供一种对该模型进行设计实验的方法，以更好的了解系统、其行为和子系统之间的关系并分析设计的各个方面。

原型设计是另一个抽象过程，在这个过程中，会对产品或系统进行部分表述。原型可能是系统的初始版本，但缺乏最终版本的全部功能。（需求征询，设计和完善系统的用户界面，验证功能要求）

#### 根源分析

RCA，旨在找出不良结果的根本原因

作用：确定需要通过工程努力解决的真正问题，在进行项目风险评估时，暴露风险的潜在驱动因素；解释软件流程改进的机会和行动；发现重复出现缺陷的根源

RCA（Root Cause Analysis，根本原因分析）技术是一种系统性的方法，用于识别和解决问题的根本原因，以避免问题的再次发生。它是一种问题解决和故障排除的方法论，广泛应用于各种领域，包括工程、质量管理、信息技术等。

RCA技术的目标是通过深入分析问题，找出导致问题发生的根本原因，而不只是处理问题的表面症状。通过解决根本原因，可以避免问题的重复发生，提高系统的可靠性和稳定性。

RCA技术通常包括以下步骤：

1. 问题定义和描述：明确问题的性质、表现和影响，确保对问题的共识。

2. 数据收集：收集与问题相关的数据和信息，包括问题发生时的环境条件、观察到的现象、相关日志和记录等。

3. 问题分析：使用不同的分析工具和方法，例如鱼骨图（Ishikawa Diagram）、5W1H（What, Why, When, Where, Who, How）等，对问题进行深入分析，确定可能的原因和相关因素。

4. 根本原因确定：通过逐步追溯和排除可能的原因，找到导致问题发生的最根本的原因。这可能涉及多个层次的原因和相互关系。

5. 解决方案和改进措施：基于根本原因的分析结果，确定有效的解决方案和改进措施，以消除根本原因并防止问题再次发生。

6. 实施和验证：实施所提出的解决方案，并验证其有效性和可行性。监控和评估改进措施的效果，并进行必要的调整。

RCA技术强调对问题的全面分析和系统思考，以找出潜在的原因和解决方案。它可以应用于各种问题，从简单的日常工作问题到复杂的系统故障和事故调查。通过使用RCA技术，组织可以提高问题解决的效率和质量，从而改善业务流程和持续改进。

#### 建模

原则：示范要点，提供视角，实现有效沟通

模型：完整性，一致性，正确性

建模的语言：语言的寓意规定了模型中补货的尸体和关系的含义。

前置条件 + 后置条件 + 不变式

模型类型：信息建模（是一种抽象表示法，确定并定义了数据实体的一系列概念、属性、关系和约束），行为建模（识别并定义被建模软件的功能，三种基本形式：状态机，控制流模型，数据流模型），结构建模（软件各个组成部分组成的物理或逻辑结构）。

#### 模型分析

1. 分析完整性
2. 分析一致性：一般是利用建模工具的自动分析功能完成，也可利用检查或其他审查技术对模型进行人工检查
3. 分析正确性：验证模型的语法，语义正确性，采用自动分析或人工分析
4. 可追溯性：采用一些方法指定和管理需求、设计、代码和测试实体之间的可追溯性联系
5. 交互分析：侧重于软件模型中用于完成特定任务或功能的实体之间的通信或控制流关系。

### 4. 软件工程方法

1. 启发式方法
   1. 结构化分析和设计方法
   2. 数据建模方法
   3. 面向对象的分析和设计方法
2. 形式化方法
   1. 规格语言
   2. 程序细化和衍生
   3. 形式验证
   4. 逻辑推理
3. 原型制作方法
   1. 原型设计风格
   2. 原型目标
   3. 原型评估技术
4. 敏捷方法
   1. 快速应用程序开发
   2. 极限编程
   3. Scrum
   4. 功能驱动开发

## 第8章 移动互联网软件架构设计视角

### 架构设计愿景

#### 架构目标

1. 高可用性（多少个9）
2. 高可扩展性（架构简单清晰，应用之间耦合度低，容易水平扩展）
3. 低成本（增加服务的重用性，提升效率，降低成本）
4. 多快好省（兼顾效率和性能，达到高人数，高时效和低成本）

#### 质量要求

1. 用户质量（易用性）
2. 系统质量（可支持性，可测试性）
3. 设计质量（概念完整性，可维护性，可重用性）
4. 运行时质量（可用性，互操作性，可管理性，性能，可靠性，可扩展性，安全性）

#### 架构原则

![截屏2023-12-12 下午8.06.46](https://github.com/ShadowOnYOU/images/blob/main/test202312122006137.png?raw=true)

### 整体架构设计

![截屏2023-12-12 下午8.08.03](https://github.com/ShadowOnYOU/images/blob/main/test202312122008705.png?raw=true)

**整体横向分层抽象，局部纵向贯穿分解**

#### 业务架构

##### 原则

1. 业务平台化
   1. 业务平台化，相互独立，如交易平台，仓储平台，物流平台
   2. 基础业务下沉，可复用，如用户、商品等
2. 核心业务，非核心业务分离
   1. 电商核心业务与非核心业务分离，核心业务精简（利于稳定），非核心业务多样化
3. 隔离不同类型的业务
   1. 交易业务是签订买家与卖家之间的交易合同，优先保证高可用性
   2. 闪购业务对高并发要求很高，应该跟普通业务隔离
4. 区分主流程、辅流程
   1. 分清哪些是电商的主流程。运行时，优先保证主流程的顺利完成，辅流程可以采用后台异步的形式。

##### 业务架构图

![截屏2023-12-12 下午8.16.34](https://github.com/ShadowOnYOU/images/blob/main/test202312122016094.png?raw=true)

#### 应用架构

##### 原则

1. 稳定性原则
   1. 一切以稳定为中心
   2. 架构尽可能简单
   3. 不过度设计
2. 解耦/拆分
   1. 稳定部分与易变部分分离
   2. 核心业务与非核心业务分离
   3. 主流程与辅流程分离
   4. 应用与数据分离
   5. 服务与实现细节分离
3. 抽象化
   1. 应用抽象化
   2. 数据库抽象化
   3. 服务器抽象化
4. 松耦合
   1. 跨域调用异步化
   2. 非核心业务尽量异步化
   3. 必须同步调用时，需要设置超时时间和任务队列长度
5. 容错设计
   1. 服务自治，避免引发连锁反应

![截屏2023-12-12 下午8.23.29](https://github.com/ShadowOnYOU/images/blob/main/test202312122023407.png?raw=true)

##### 架构分解原则

![截屏2023-12-12 下午8.26.23](https://github.com/ShadowOnYOU/images/blob/main/test202312122026758.png?raw=true)

##### 依赖原则

1. 依赖稳定部分
   1. 稳定部分不依赖易变部分
   2. 易变部分可以依赖稳定部分
   3. 避免循环依赖
2. 跨域弱依赖
   1. 跨业务调用时，尽可能异步弱依赖
3. 基本服务依赖
   1. 基本服务不能向上依赖流程服务
   2. 组合服务、流程服务可以向下依赖基本服务
   3. 基本服务稳定
4. 非功能性服务依赖
   1. 非功能性服务不依赖功能性服务
   2. 功能性服务可依赖非功能性服务
   3. 非功能性服务稳定
5. 平台服务依赖
   1. 平台服务不依赖上层应用
   2. 上层应用可依赖平台服务
   3. 平台服务稳定
6. 核心服务依赖
   1. 核心服务不依赖非核心服务
   2. 非核心服务可依赖核心服务
   3. 核心服务稳定

#### 访问远程服务

##### 远程方法调用（RPC）

RPC（Remote Procedure Call）是一种用于实现分布式系统中不同进程或计算机之间通信的技术。它允许一个进程（称为客户端）调用另一个进程（称为服务器）上的函数或方法，就像调用本地函数一样，隐藏了底层的网络通信细节。

RPC的工作原理如下：

客户端调用：客户端应用程序调用本地的代理对象（通常是生成的客户端存根），就像调用本地函数一样。客户端不需要关心底层的网络通信细节。

代理对象封装：代理对象将函数调用信息封装成一个消息，包括要调用的函数名称、参数等，并将消息通过网络发送给服务器。

网络传输：消息通过网络传输到服务器端。

服务器端处理：服务器端接收到消息后，将消息解析，并根据消息中的函数名称和参数执行相应的函数或方法。

结果返回：服务器端执行完函数后，将结果封装成消息，并通过网络发送给客户端。

客户端响应：客户端接收到服务器端返回的消息后，将结果解析，并返回给调用者。

##### 表征状态转移（REST）

resource：资源

表征：浏览器想服务端发出请求“我需要这个资源的HTML格式”，服务端向浏览器返回的这个HTML就是“表征”

状态：有状态与无状态。例如我向服务器发出请求“给我下一篇文章”，但是下一篇是一个相对概念，必须依赖你当前正在阅读的文章，这类在特定语境中才能产生的上下文信息即被称为“状态”。

转移：无论状态是由服务端还是客户端提供的，“取下一篇文章”这个行为逻辑必然只能由服务端来提供，因为只有服务端拥有该资源及其表征形式。服务端通过某种方式，把“用户当前阅读的文章”转变为“下一篇文章”，这就是“表征状态转移”。

统一接口：包括：GET，HEAD，POS T，PUT，DELETE，TRACE，OPTIONS七种基本操作，任何一个支持HTTP协议的服务器都会遵守这套规定。

超文本驱动：浏览器作为所有网站的通用的客户端，任何网站的状态转移行为都不可能是预置于浏览器代码之中，而是由服务器发出的请求响应信息（超文本）来驱动的。这与其他带有客户端的软件由十分本质的区别，那些软件中，业务逻辑往往是预置于程序代码中的，有专门的页面控制器驱动页面的状态转移。

自描述消息：由于资源的表征可能存在多种不同形态，在消息中应当有明确的信息来告知客户端该消息的类型以及如何处理这条消息。常用的自描述方法是在Content-Type的HTTP header中标识出互联网媒体类型

REST（Representational State Transfer）是一种基于现有的Web标准和协议的架构风格，用于构建可扩展的、分布式的网络应用程序。REST是一种轻量级的通信方式，常用于设计和实现Web服务和API。

REST的关键原则包括：

资源（Resources）：在REST中，所有的数据都被视为资源，每个资源都有一个唯一的标识符（URI）来进行访问。资源可以是实体对象、集合、文件等。

统一接口（Uniform Interface）：REST使用一组统一的、标准的HTTP方法（如GET、POST、PUT、DELETE）来对资源进行操作。每个HTTP方法都有明确的语义，用于表示对资源的不同操作。

无状态（Stateless）：REST的通信是无状态的，即服务器不会存储客户端的状态信息。每个请求都是完全独立的，服务器不会保留之前请求的上下文。

按需编码（Cacheable）：REST支持使用缓存来提高性能和减少对服务器的请求。服务器可以通过在响应中设置适当的缓存头信息，告知客户端是否可以缓存响应数据。

分层系统（Layered System）：REST支持构建分层的系统结构，其中客户端无需了解请求的具体处理方式。中间层（如代理服务器、负载均衡器等）可以处理请求，提供负载均衡、安全性等功能。

通过REST，客户端可以通过HTTP协议访问和操作服务器上的资源。客户端发送HTTP请求（如GET、POST、PUT、DELETE）到服务器的特定URI，服务器根据请求的方法和URI来执行相应的操作，并返回适当的HTTP响应（如状态码、响应体）给客户端。

RESTful API是基于REST原则设计的Web服务接口，使用HTTP作为通信协议，并遵循REST的约定和规范。它通常使用JSON或XML作为数据交换格式，通过HTTP方法和URI来操作资源。

#### JSF

核心技术——协议：使用Nett来实现网络协议栈，异步事件通讯框架

同一端口同时支持Http、TCP协议访问

TCP长链接下使用自动移二进制协议

HTTP网关来应对跨语言访问

核心技术——callback

TCP长链接是双工的，服务方可以主动推送消息到调用方

调用端检测到参数列表中有Callback类型，登记相应的callback对象；服务端收到调用时，生成相应的反向调用代理

服务端持有此代理，并在需要时调用此代理来推送消息

#### 数据架构

##### 设计原则

1. 同一数据视图
   1. 保证数据的及时性，一致性，准确性，完整性
2. 数据、应用分离
   1. 应用系统只依赖逻辑数据库
   2. 应用系统不直接访问其他宿主的数据库，只能通过服务访问
3. 数据异构
   1. 如卖家库和卖家库
4. 数据读写分离
   1. 访问量大的数据库做读写分离
   2. 数据量大的数据库做分库分表
   3. 不同业务域数据库做分区隔离
   4. 重要数据配置备库
5. 用Mysql数据库
   1. Mysql的数据库扩展性和支持高并发的能力较强
6. 合理使用缓存
   1. 数据库有能力支撑时，尽量不要使用缓存

![截屏2023-12-12 下午9.30.07](https://github.com/ShadowOnYOU/images/blob/main/test202312122130398.png?raw=true)



#### 技术架构

服务设计原则

无状态，可复用，松耦合，可治理

##### 系统运行时原则

1. 可监控
   1. 当服务的TPS和RT符合SLA时，意味着服务在合同或协议规定的时间范围内达到了预期的性能水平。
2. 应用可回滚，功能可降级
   1. 应用出现问题时要求能回滚到上一个版本
3. 在线扩容
   1. 超预期流量时，应用系统可选择在线水平扩展
4. 安全保证
   1. 确保系统保密性和完整性
   2. 具有足够的防攻击能力
5. 可容错
   1. 核心应用要求多活，避免单点设计
6. 可故障转移
   1. 多机房部署

##### 系统部署原则

1. N + 1原则
   1. 为故障多搭建一套系统
   2. 功能开发与运维分开
2. D-I-D原则
   1. 设计20倍容量
   2. 实现3倍容量
   3. 部署1.5倍容量
3. 支持灰度发布
   1. 灰度发布：在灰度发布中，新版本的软件或功能首先在一小部分用户或服务器上进行部署和测试，而其他用户或服务器仍然继续使用老版本。这样可以在有限的范围内测试新版本的功能和性能，同时观察是否出现任何问题或异常。如果新版本通过了测试并被认为稳定可靠，就可以逐步扩大部署范围，将新版本推广到更多的用户或服务器中。
4. 虚拟化部署
5. 业务子网
   1. 机房部署以业务域划分：基本服务和数据库。
   2. 相同业务域的服务器部署在一起；不同业务域的服务器物理隔离

### 架构设计视角

![截屏2023-12-12 下午9.42.24](https://github.com/ShadowOnYOU/images/blob/main/test202312122142277.png?raw=true)

![截屏2023-12-12 下午9.43.01](https://github.com/ShadowOnYOU/images/blob/main/test202312122143489.png?raw=true)





### 总结

![截屏2023-12-12 下午9.39.49](https://github.com/ShadowOnYOU/images/blob/main/test202312122139832.png?raw=true)

![截屏2023-12-12 下午9.43.35](https://github.com/ShadowOnYOU/images/blob/main/test202312122143702.png?raw=true)

![截屏2023-12-12 下午9.43.54](https://github.com/ShadowOnYOU/images/blob/main/test202312122143810.png?raw=true)



## 第9章 移动互联网设计架构——架构设计视角

### 1. 大型网站架构演化历程

![截屏2023-12-14 上午10.18.24](https://github.com/ShadowOnYOU/images/blob/main/test202312141018411.png?raw=true)

![截屏2023-12-14 上午10.18.01](https://github.com/ShadowOnYOU/images/blob/main/test202312141018587.png?raw=true)

#### 进行优化的点

1. 应用服务和数据服务分离
2. 使用缓存改善网站性能
3. 使用应用服务器集群改善网站的并发处理能力
4. 数据库的读写分离
5. 使用反向代理和CDN加速网站响应
   1. 反向代理是一种服务器架构，在反向代理中，用户向代理服务器发送请求，代理服务器再将请求转发给真实的服务器，然后将服务器返回的响应再返回给用户。反向代理服务器再真实服务器和用户之间，可以缓存静态内容并将其提供给用户，从而减轻真实服务器的负载并加快响应时间。
   2. CDN是一组全球不同地理位置的服务器网络，这些服务器存储并发网站的静态资源（图像、CSS、JavaScript）。当用户请求访问网站时，CDN会根据用户的地理位置选择距离最近的服务器提供资源，以减少数据传输的延迟，提高网站的加载速度。
6. 使用分布式文件系统和分布式数据库系统
   1. 将数据存储在多个物理节点上
   2. 因为数据可以并行处理，并且可以通过增加节点来扩展系统的容量。
7. 使用NoSQL和搜索引擎
   1. 大规模数据的存储和检索
8. 业务拆分
9. 分布式服务

### 2. 高可用

#### 负载均衡与反向代理

1. 四层 vs 七层：负载均衡可以在网络层（四层）或应用层（七层）进行。四层负载均衡基于IP地址和端口号进行请求转发，而七层负载均衡不仅考虑了IP地址和端口号，还根据请求的具体内容（如URL信息）进行转发。
2. IP+端口（四层）LVS Linux Virtual Server：LVS是一种基于Linux的四层负载均衡解决方案。它通过在负载均衡器前面设置一组服务器，并使用IP地址和端口号进行请求分发，实现负载均衡。
3. Web请求、URL信息（七层）Nginx：Nginx是一种流行的七层负载均衡器和反向代理服务器。它除了可以基于IP地址和端口号进行负载均衡外，还可以根据请求中的URL信息进行转发，以便更精确地处理特定的应用请求。
4. 都支持HAProxy：HAProxy是另一个常用的开源负载均衡器，可以在四层和七层进行负载均衡。
5. 算法：
   - Round-robin（轮询）：将所有节点看作一个圆，按顺时针方式轮流选择一个节点进行请求转发。
   - 带权重的轮询选择：为每个节点分配不同的权重，根据权重比例选择节点，以实现不同节点的负载均衡。
   - IP Hash：根据客户端的IP地址对请求进行散列，并将同一IP的请求转发到同一台服务器上，这样可以保持会话的一致性。l

负载均衡技术可以提高系统的性能、可靠性和可扩展性，确保服务器资源被充分利用，并为用户提供更好的服务体验。选择适合的负载均衡算法和实现方式取决于具体的应用需求和系统架构。

![截屏2023-12-14 上午10.35.43](https://github.com/ShadowOnYOU/images/blob/main/test202312141035178.png?raw=true)

##### 反向代理

proxy cache提供缓存来减少服务器的压力

location配置：location配置用于匹配请求的URL，即ngnix中的$request_url变量

gzip压缩：通过压缩相应数据，可以减少传输数据的大小。但是由于压缩发生在请求的处理过程，会增加相当大的处理开销，增大延时，对性能产生负面影响。Nginx会对数据发送到客户端之前进行压缩，但是对于已经压缩过的数据不会进行二次压缩。

##### location语法

![截屏2023-12-14 上午10.42.26](https://github.com/ShadowOnYOU/images/blob/main/test202312141042402.png?raw=true)

![截屏2023-12-14 上午10.42.42](https://github.com/ShadowOnYOU/images/blob/main/test202312141042416.png?raw=true)

![截屏2023-12-14 上午10.43.39](https://github.com/ShadowOnYOU/images/blob/main/test202312141043758.png?raw=true)

前缀匹配下，返回最长匹配的location，与location所在位置顺序无关![截屏2023-12-14 上午10.47.22](https://github.com/ShadowOnYOU/images/blob/main/test202312141047218.png?raw=true)

正则匹配是使用文件中的顺序，先匹配成功的返回![截屏2023-12-14 上午10.47.13](https://github.com/ShadowOnYOU/images/blob/main/test202312141047037.png?raw=true)

![截屏2023-12-14 上午10.48.11](https://github.com/ShadowOnYOU/images/blob/main/test202312141048648.png?raw=true)

#### 隔离

##### 线程隔离

核心业务线程池，非核心业务线程池

##### 进程隔离

不同的子系统

ps：线程 && 进程

进程是程序的一次执行过程，是资源分配和调度的基本单位，拥有独立的内存空间；线程是进程中的一个执行单元，是操作系统进行调度的基本单位，共享进程的内存空间。

在多核处理器上，多个线程可以同时运行在不同的核上，实现真正的并发执行；而进程的并发执行是通过操作系统的时间片轮转实现的，每个进程在同一时间片内只能占用一个核。

##### 集群隔离

为秒杀服务提供单独的商品服务集群

##### 机房隔离

每个机房的服务都有自己的服务分组，不进行跨机房调用

##### 读写隔离

通过主从模式将读和写集群分离

主节点是系统的核心节点，负责处理业务逻辑，接收和处理客户端的请求。主节点通常具有写权限，可以执行数据的写入和更新操作。主节点还负责将数据的变更操作同步到从节点。

从节点是主节点的备份节点，用于提供冗余和高可用性。从节点从主节点复制数据，并提供读取请求的服务。从节点通常只具有读权限，不允许直接进行数据的写入和更新操作。

##### 动静隔离

CDN

##### 爬虫隔离

在负载均衡层面将爬虫路由到单独集群

##### 热点隔离

秒杀，读热点（多级缓存），写热点

![截屏2023-12-14 上午10.57.28](https://github.com/ShadowOnYOU/images/blob/main/test202312141057434.png?raw=true)

##### 环境隔离

##### 压测隔离

##### 缓存隔离

##### 查询隔离

#### 限流

算法：令牌桶（固定容量令牌的桶，按照固定速率向桶里添加令牌），漏桶（固定速率流出请求），计数器

##### 应用级限流：

总并发/连接/请求数；总资源数；某个接口的总并发/请求数；某个接口的时间窗请求数；平滑限流某个接口的请求数

##### 分布式限流

1. Redis + Lua
   1. 计数器限流
   2. 令牌环限流
   3. java调用Lua脚本
2. Nginx + Lua
   1. nginx调lua接口

#### 降级

1. 按日志级别
2. 按是否自动化
3. 按功能
   1. 页面降级、页面变短降级、页面异步请求降级、服务功能降级、读降级、写降级、爬虫降级、风控降级
4. 按处于系统层次
   1. 页面JS、接入层、应用层

#### 超时与重试机制

##### 工具

分布式配置中心

Hystrix实现隔离、熔断、降级

##### 超时

代理层超时，web容器超时，数据库客户端超时，NoSql客户端超时，业务超时，前端Ajax超时

#### 回滚

事务回滚，代码库回滚，部署版本回滚，数据版本回滚，静态资源回滚

#### 压测和预案

系统压测：线下 + 线上

系统优化与容灾

应急预案：分机、全链路分析、配置监控报警、指定应急预案

##### 美团高可用性案例分析

高可用对应的复杂性不可避免，

多元业务模式互斥

![截屏2023-12-14 下午4.21.58](https://github.com/ShadowOnYOU/images/blob/main/test202312141622162.png?raw=true)

非线性超大体量计算引擎

![截屏2023-12-14 下午4.23.01](https://github.com/ShadowOnYOU/images/blob/main/test202312141623460.png?raw=true)

##### 高可用的应对方法

1. 事前：预防（错误变更可控、极限容量摸底、设施故障可控）
2. 事中：韧性（整体柔性可用、过载保护、故障压制、可伸缩可扩展）
3. 事后：快速反应（可观测性、快速恢复能力）

### 3. 高并发

#### 应用级缓存

缓存命中率

回收策略：基于空间，基于容量，基于事件，基于java对象

算法：FIFO，LRU，LFU

软引用（SoftReference），弱引用（WeakReference），虚引用（PhantomReference）

##### java缓存类型

* 堆缓存（Heap Cache）：

将缓存对象存储在JVM堆内存中。
适用于需要快速访问的小规模数据。
优点是读写速度快，但受限于堆内存的大小。

* 堆外缓存（Off-Heap Cache）：

将缓存对象存储在JVM堆外内存中。
通过使用DirectByteBuffer等方式，绕过Java堆内存的限制。
适用于需要缓存大量数据，且对读写速度要求较高的场景。
优点是可以利用更多的物理内存，但需要手动管理内存。

* 磁盘缓存（Disk Cache）：

将缓存对象存储在磁盘上，通常以文件的形式。
适用于需要缓存大量数据，且对读写速度要求不高的场景。
优点是可以存储大容量的数据，但读写速度相对较慢。

* 分布式缓存（Distributed Cache）：

将缓存对象分布式地存储在多台服务器上。
通过网络通信实现缓存的共享和协同。
适用于需要缓存大量数据，且对读写速度和高可用性要求较高的场景。
优点是可以横向扩展，提供高性能和高可用性。

##### 缓存使用模式

1. Cache-Aside（旁路缓存）：
   - 在Cache-Aside模式中，应用程序显式地管理缓存。当应用程序需要访问数据时，首先会查询缓存。如果缓存中存在所需的数据，应用程序直接从缓存中获取。如果缓存中不存在所需的数据，应用程序会从数据源（如数据库）中获取数据，并将数据存储到缓存中，以供将来的访问使用。
   - 这种模式下，缓存并不自动更新或失效，应用程序需要负责在必要时更新或清除缓存中的数据。这样可以确保缓存中的数据始终与数据源保持同步，并减少了缓存中数据过期的风险。

2. Cache-As-SoR（缓存即源）：
   - 在Cache-As-SoR模式中，缓存被视为数据源（System of Record，SoR）的一部分，应用程序直接从缓存中读取和写入数据。数据源可以是数据库、文件系统或其他数据存储系统。
   - 这种模式下，缓存负责处理数据的读写操作，并提供数据的高速访问。当应用程序需要访问数据时，首先会查询缓存。如果缓存中存在所需的数据，应用程序直接从缓存中获取。如果缓存中不存在所需的数据，缓存会从数据源中获取数据，并将数据存储到缓存中，以供将来的访问使用。同时，缓存还负责更新数据源中的数据。

#### HTTP缓存

分布式缓存解决热点数据问题

热点数据解决方案：单机全量缓存 + 主从（小规模）； 分布式缓存 + 应用本地热点（大规模）

1. 单机全量缓存+主从：
   - 在单机环境下，使用全量缓存将热点数据存储在内存中，以提高读取性能。
   - 通过主从复制机制，将数据同步到多个副本中，增加数据的可用性和读取并发性。
2. 分布式缓存+应用本地热点：
   - 使用分布式缓存（如Redis、Memcached等）存储热点数据，将数据分布在多台服务器上。
   - 应用程序在访问热点数据时，首先从本地缓存中获取，如果缓存中不存在，则从分布式缓存中获取，并将数据缓存在本地。
   - 这样可以减轻分布式缓存的负载，提高读取性能，并减少网络开销。

实时热点数据发现系统：请求上报，写到本地kafka，storm实时计算（动态识别热点数据）

#### 连接池

作用：用于提高资源的复用性和性能

1. 数据库连接池：
   - 数据库连接池用于管理数据库连接的创建、复用和释放。
   - 通过预先创建一定数量的数据库连接并存储在连接池中，应用程序可以从连接池中获取连接，而不是每次都创建新的连接，从而避免了频繁的连接创建和销毁开销。
   - 常见的数据库连接池实现包括Apache Commons DBCP、C3P0、HikariCP等。

2. HttpClient连接池：
   - HttpClient连接池用于管理HTTP请求的连接的创建、复用和释放。
   - 在发送HTTP请求时，应用程序可以从连接池中获取连接，而不是每次都创建新的连接，从而提高了请求的执行效率和性能。
   - HttpClient库自带了连接池的支持，可以通过配置连接池的参数来控制连接的数量、超时等。

3. 线程池：
   - 线程池用于管理线程的创建、复用和回收。
   - 通过预先创建一定数量的线程并存储在线程池中，应用程序可以将任务提交给线程池执行，而不是每次都创建新的线程，从而避免了频繁的线程创建和销毁开销。
   - Java提供了ThreadPoolExecutor类来实现线程池，可以通过配置线程池的参数来控制线程的数量、线程池的大小、任务队列等。

4. Tomcat线程池：
   - Tomcat线程池是用于处理HTTP请求的线程池，通常与Tomcat应用服务器相关。
   - Tomcat线程池负责管理处理HTTP请求的线程，以支持并发的请求处理。
   - 可以通过配置Tomcat的server.xml文件来调整线程池的参数，如最小线程数、最大线程数、超时时间等。

#### 异步并发

* 请求商品详情页：

发起请求获取商品的基本信息，例如商品名称、描述等。
可以使用异步的方式发送请求，例如使用Java的CompletableFuture、RxJava等库来实现异步操作。

* 获取库存：

发起异步请求获取商品的库存信息，例如当前库存数量。
可以通过调用库存服务的API接口或使用消息队列来异步获取库存信息。

* 获取促销信息：

发起异步请求获取商品的促销信息，例如折扣信息、优惠券等。
可以通过调用促销服务的API接口或使用消息队列来异步获取促销信息。

* 获取价格：

发起异步请求获取商品的价格信息，例如原价、折后价等。
可以通过调用价格服务的API接口或使用消息队列来异步获取价格信息。

#### 扩容

#### 队列

#### 下单实例

![截屏2024-01-03 下午10.31.05](https://github.com/ShadowOnYOU/images/blob/main/test202401032231985.png?raw=true)



