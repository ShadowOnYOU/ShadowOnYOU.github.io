---
layout: post
title: 服务端开发——依赖注入
categories: [服务端开发]
description: some word here
keywords: 服务端开发
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 服务端开发——依赖注入

## 1. GIT的关键概念

## 2. spring web开发框架的分层

请求-》控制层-〉业务层-》数据访问层-〉数据库

## 3. 使用JUint写测试用例

## 4. Spring的模块组成

### 4.1 Spring的核心是提供了一个容器

![截屏2023-09-14 18.57.34](https://github.com/ShadowOnYOU/images/blob/main/test202309141858961.png?raw=true)

### 4.2 三种机制

1. 自动配置
2. javaconfig
3. xml配置

![截屏2023-09-14 19.07.15](https://github.com/ShadowOnYOU/images/blob/main/test202309141907880.png?raw=true)

component注解

autowired注解

**注意：**

![截屏2023-09-14 20.12.31](https://github.com/ShadowOnYOU/images/blob/main/test202309142014859.png?raw=true)

返回上下文中唯一的，因为已经存在一个conpactdisk对象。

Componentscan的属性：

1. basepackets（可以指定多个，指定的包路径）

-》有类型不安全的问题。（写错了编译器不会给我第一时间的报错）

2. basepacketsclass（这种是类型安全的，编译器能反馈错误，但还是很难保证后期修改后，这个类依然存在）-》解决方法：设置一个特殊标记类。给他提供搜索路径。![image-20230914202059445](https://github.com/ShadowOnYOU/images/blob/main/test202309142020470.png?raw=true)

第二种：使用config适用于修改第三方代码不方便时。使用bean创建实例

## bean的生命周期

有BeanNameAware，它有一个函数setBeanName

有ApplicationContextAware。有函数setAplicationContext（可以用于抓取上下文的引用）



## 第三种方法——xml

![image-20230914203157452](https://github.com/ShadowOnYOU/images/blob/main/test202309142031475.png?raw=true)

构造方法的参数——constructor-arg

## 补充：课后课件再整理

## 1. Spring的模块组成

![截屏2023-09-16 14.18.25](https://github.com/ShadowOnYOU/images/blob/main/test202309161418814.png)

## 2. Spring的两个核心技术

1. DI（依赖注入）
   1. 保留抽象接口，让组件（component）依赖于抽象接口，当组件要与其他世纪的对象发生依赖关系时，由抽象接口来注入以来的实际对象。
2. AOP
   1. 通过预编译方法和运行期间动态代理实现程序功能的统一维护。
   2. 使用AOP对业务逻辑的哥哥部分进行隔离，从而使得业务逻辑个部分之间的耦合度降低。

Spring容器是一个运行时环境，负责创建、管理和组装应用程序中的对象（也称为bean）。它使用依赖注入（Dependency Injection）来解决对象之间的依赖关系，并提供了其他功能，如生命周期管理、AOP（面向切面编程）、事务管理等。

## 3. bean的生命周期

1. **实例化（Instantiation）**：在这个阶段，Spring容器根据配置元数据（如XML配置文件、注解或Java配置类）创建Bean的实例。这通常涉及到调用Bean的构造函数来实例化对象。
2. **属性填充（Population）**：在这个阶段，Spring容器将依赖注入（Dependency Injection）应用于Bean。它会通过设置Bean的属性或通过调用Bean的setter方法将依赖项注入到Bean中。
3. **初始化（Initialization）**：在这个阶段，Spring容器会调用Bean的初始化回调方法。开发人员可以通过实现`InitializingBean`接口或使用`@PostConstruct`注解来定义初始化回调方法。这个阶段允许开发人员执行一些初始化逻辑，如建立数据库连接、加载配置文件等。
4. **销毁（Destruction）**：在Bean的生命周期结束时，Spring容器可以调用Bean的销毁回调方法来释放资源。开发人员可以通过实现`DisposableBean`接口或使用`@PreDestroy`注解来定义销毁回调方法。这个阶段可以用于执行一些清理操作，如关闭数据库连接、释放文件资源等。![截屏2023-09-16 14.26.09](https://github.com/ShadowOnYOU/images/blob/main/test202309161426260.png)

## 4. Spring配置方案

### 4.1 自动化配置

1.  component scanning：组件扫描
2. autowiring：自动装配
3. **自动化配置（Auto-configuration）**：自动化配置是Spring Boot框架的一个重要特性。它通过约定大于配置的原则，根据应用程序的类路径和依赖关系自动配置Spring应用程序。自动化配置消除了大部分传统Spring应用程序中需要手动进行的繁琐配置步骤。例如，当您引入Spring Boot的Web模块时，它会自动配置Servlet容器、Spring MVC、错误处理等，而无需显式配置。在自动化配置中，您可以通过修改配置属性来自定义配置的行为。

以下是一个简单的Spring Boot自动化配置示例：

```
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}
```

在上述示例中，`@SpringBootApplication`注解标记了主应用程序类，并且它隐式地启用了自动配置。通过`SpringApplication.run()`方法，Spring Boot将自动检测并配置应用程序所需的组件和依赖关系。

### 4.2 JavaConfig

1. 自动化配置有时行不通，如第三方库
2. configuration
3. bean（name = “”）
4. **Java配置（Java-based Configuration）**：Java配置是通过编写纯Java代码来配置Spring应用程序的一种方式。您可以创建一个Java配置类，使用特定的注解来定义Bean和配置信息。

以下是一个简单的Java配置示例：

```
@Configuration
public class AppConfig {
    
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
    
    @Bean
    public AnotherBean anotherBean() {
        return new AnotherBean(myBean());
    }
}
```

在上述示例中，`@Configuration`注解标记了Java配置类，并且`@Bean`注解用于定义Bean。`myBean()`方法和`anotherBean()`方法分别定义了两个Bean，并通过`myBean()`方法进行依赖注入。

### 4.3 XML配置

1. **XML配置（XML-based Configuration）**：XML配置是使用XML文件来配置Spring应用程序的传统方式。您可以编写一个XML配置文件，通过配置元素和属性来定义Bean和配置信息。

以下是一个简单的XML配置示例：

```
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">
       
    <bean id="myBean" class="com.example.MyBean"/>
    
    <bean id="anotherBean" class="com.example.AnotherBean">
        <constructor-arg ref="myBean"/>
    </bean>
</beans>
```

在上述示例中，`<bean>`元素用于定义Bean，`id`属性指定Bean的标识符，`class`属性指定Bean的类名。`<constructor-arg>`元素用于进行构造函数注入，通过`ref`属性引用另一个Bean。
