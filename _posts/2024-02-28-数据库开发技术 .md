---
layout: post
title: 数据库开发技术
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 开发数据库的要点

bitmap的传奇故事

理解数据库体系结构

理解锁和并发控制特性

不要把数据库当黑盒

适当的性能和安全

为什么新浪用web：html快速，高效。不使用动态界面

简单的方法：循环中的SQL 往往 都能转化成SQL中的循环（SQL本身就是循环的）



## 并发控制

oracle锁机制

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Database-Development/img/lec2/1.png)

按理来说需要回滚

但是oracle会直接提交。会有脏读

美其名曰：读一致（读当下时间点的数据，永远能读到开始读的时间点的数据，而不是修改后的数据）。整体的吞吐量提高

### 多版本一致性读：

oracle的好处：在他们的理解中读锁应该是不存在的。

example：想运行一个日报表，了解银行有多少钱。SUM

oracle实现的锁机制：

1. 只有修改才能加行级锁
2. read绝对不会对数据枷锁
3. 读绝不会阻塞写



**事务、分布、存储就是最重要的体系结构**

索引是什么：是一个排序的数据结构，以协助快速查询、更新数据库表中数据。



何时需要考虑并发：不知道，看情况

我的程序可以适配多种数据库：实际上这是不可行的（，每种数据库都有自己的特性

数据库之间的差异性（NULL = NULL）

专家 参数调整 大概提升20%～30%



数据库对性能指标的：不是1s有多少的反馈。而是每秒处理多少事务。还能反映系统的吞吐量

3001 vs 3000:阻塞蔓延（不是3000 * 1 + 1 * 2，而是2000 * 1 + ～～～）



优化工具：找到堵点在哪里；把拥堵点对应的SQL定位到程序体



性能优化

主要就是CPU负载 与 IO负载



小IO但大量（FOR + SQL）



SQL优化方向：索引，执行计划，SQL语句优化，物理分库分表，数据库表结构，整体结构设计



差异：限用Boolean字段

SQL中并不存在Boolean类型

数据库的设计：每个字段要有独立的意义

1NF：学好不能被拆分（例如对211250033进行拆解）

数据越简单越好

数据库性能最大的压力：最大的压力（插成），自定义的函数影响性能



select ** from ** where **（where处会每一行运行一次，而select处只会运行一次）



差异：过于灵活的危险性

四通用表设计：

实体表（Entity Table）：实体表用于存储不同实体类型的共享属性。每个实体类型对应一个实体表，其中包含该实体类型的所有共同属性列。例如，如果有多个实体类型（如人、组织、产品），每个实体类型都有一些共同的属性（如名称、创建日期），那么可以创建一个实体表来存储这些共享属性。

属性表（Attribute Table）：属性表用于存储实体的特定属性。每个属性对应一个属性表，其中包含属性的名称和值列，以及与实体表的关联列。通过将实体的属性存储在属性表中，可以减少数据冗余，并且可以灵活地扩展和修改属性。

关系表（Relationship Table）：关系表用于存储实体之间的关系。它包含与实体表相关的外键列，用于建立实体之间的连接。关系表中的行表示实体之间的关联，可以存储额外的关系属性。例如，如果有人与组织之间的关系，可以创建一个关系表来存储人员ID和组织ID之间的关联。

值表（Value Table）：值表用于存储实体的多值属性。多值属性是指一个实体可以有多个值的属性，例如一个人可以有多个电话号码。值表包含与实体表的关联列以及属性值列，用于存储多个属性值。通过将多值属性存储在值表中，可以避免将多个属性值存储在单个列中，从而提高数据的灵活性和可扩展性。

缺点：任何属性的查询都涉及到表连接



差异：约束应明确说明

数据中存在隐含约束是一种不良设计

一个数据库给一个应用使用（都可以），除此之外（我们喜欢把表结构的限制条件限制在数据库中）



设计：理解子类型

例子：运动员（子类型一个很重要的不是类型有多少个，而是有没有跨越子类型的例子存在，与查询息息相关）

如何解决跨越：一般多一张link的表（1250 游泳，1250 100米）



设计：如何处理历史数据

历史数据：商品在某一时刻的价格

对于时间的SQL处理不强（一定会是一个区间）



架构：处理流程

异步模式处理（批处理），同步模式（实时处理）



面向列存储主要是为了分析



存储：数据布局只是针对应用可能的优化步骤之一

# 索引结构、实现及使用

什么是**索引**：DBMS中一个排序的数据结构，以协助快速查询，更新数据库表中数据

使用的数据结构：树

## BST

BST：二分搜索树

节点：键，值，两个指针，

需要进行balance：否则会出现病态的树

如何进行balance：添加或删除节点后执行旋转

平衡的本质：沿着左或右指针移动会将搜索空间平均减少一半。



BST是一个**很好的用作内存存储的方式**，但是**不适合**用作磁盘的存储结构：磁盘涉及到块

读得越快一定写的越慢

针对性的作出一些修改：扇出，树高（树越矮，读区次数少，读取效率高）

扇出：每个节点允许的最大的子节点。树高：树的高度

高扇出（改善临近键的数据局限性），低高度（减少遍历期间的寻道次数）



HDD和SSD的差异：block和page的概念不太重要（不清楚，看情况）

磁盘是删除不掉东西的。都是覆盖操作

**两种方法**：行迁移（节省空间，当然我们只允许一次行迁移），删除并覆盖（删除干净，再后面补充一下）

## B+树

![截屏2024-05-06 下午8.44.27](https://github.com/ShadowOnYOU/images/blob/main/test202405062044584.png?raw=true)

![](https://github.com/ShadowOnYOU/images/blob/main/test202405062046345.png?raw=true)

问题：是不是只有叶节点存值是B+ 树和B树的差异？

答案：不完全正确，

1. 内部节点存储方式：在B树中，每个节点既存储键值也存储对应的值。而在B+树中，内部节点只存储键值，而不存储对应的值。值只被存储在叶节点中。这意味着B+树的内部节点可以容纳更多的键值，从而减少了树的高度和磁盘访问次数。
2. 叶节点存储方式：B树的叶节点存储键值和对应的值。而B+树的叶节点只存储键值和指向对应值的指针（或者叫做引用）。这使得B+树的叶节点形成一个有序链表，方便范围查询和顺序访问。
3. 范围查询：由于B+树的叶节点形成有序链表，范围查询在B+树上更加高效。可以通过在链表上进行顺序遍历来获取范围内的所有键值。
4. 数据查找：在B树中，由于每个节点都存储对应的值，因此数据查找时可以在内部节点中找到匹配的键值，而不必总是访问到叶节点。而在B+树中，由于值只存储在叶节点中，因此数据查找必须从根节点一直到叶节点。



B树结构是一个大类，包含最常使用的B+树

#### 【B+树结构之后应该会考】

每个节点最多N个键和N+1个指向节点的指针

注意：根节点等只做过程的比较（只存key，不存value），只有叶节点存储数据

节点容量和实际持有键的数量之间的关系叫占用率。（阈值大致在50%）

所有相邻的叶节点间存在同级的节点指针（针对范围查询（大于小于））

B树的本质特点：高扇出，低树高。**是自下而上的，随着叶节点数量的增加，内部节点的数量和树的高度也将增加**

#### B+树的实际应用：

在实际应用中，当我们为数据库中的数据增加B+树索引时，B+树的叶节点存储的是实际的**数据记录**或者**数据记录的引用**（指针）。

具体来说，对于一个具体的数据库表，我们可以选择一个或多个列作为索引的键。当创建B+树索引时，B+树的叶节点会存储与该索引键对应的数据记录或数据记录的引用。

例如，假设我们有一个名为"students"的数据库表，其中包含学生的信息，包括学生ID、姓名、年龄等列。我们决定为学生ID这一列创建B+树索引。在这种情况下，B+树的叶节点将存储学生ID对应的完整数据记录或数据记录的引用。

这种设计使得在根据索引进行查询时，可以通过B+树的索引结构快速定位到叶节点，然后获取相应的数据记录。由于B+树的叶节点形成有序链表，因此也方便进行范围查询和顺序访问。

需要注意的是，索引并不是存储实际数据的副本，而是对数据的引用或索引。这样可以减少索引的存储空间，并在插入、更新和删除数据时更高效地维护索引结构。



// 2024.5.6 看到这里

B树查找算法

两个角度：块传输，键比较

复杂度log2M（键是M，每个节点的键数N）



B树的节点分裂【这一块很重要】

B树的节点合并【这一块非常重要】

不同的数据库可能会有不同的分裂和合并的方法

存在的问题：过于紧凑的数据安排导致合并与分裂频繁的触发

为了减少分裂和合并的次数，DBMS会使用“再平衡”。大概的意思就是说我们预先留一些空位（对满和空进行额外的一些设置）

索引结构是为了先定位

B树索引可以应用的场景：全键值，键值范围，键前缀查找

不能做：键中值查询，where后面有函数等

叶节点：里面存的是键值对。



索引对数据的访问只是第一步

两种：二级索引指向主键索引，主再访问表；二级和主键相同的效力

何者更优：不知道，看情况（后者效率更高一些（读有利，写不利），但是前者的更新只需要修改主键索引，二级索引没有更新的压力）【请好好思考读写矛盾】



索引的另一面：

磁盘空间的占用（索引是空间换时间）

索引有利于读一定不利于写

磁盘处理的开销

b+更有利于精确查询。（经验数据10%，块的数量的10%）





Mysql中不同的存储引擎使用了不同的方法把索引保存到磁盘上

压缩：key很难被压缩，value的值可以被压缩

复合索引（a一样，c不一样）（长度不等的C进行后面空白的压缩）

表小或许使用索引降低查询效率



哈希索引（优化了时间，空间，但是满足不了功能）

**高效的全键值比对**（例如身份证号的比对，因为前缀相同的很多）

生成hash值

能做什么：全键值

不能做范围（相邻的内容不会生成相邻的hash值），也不能做前缀（hash的值是根据全键生成的）

碰撞率问题：会多一步计算的操作（来源于设计本身，和hash的函数没啥关联）

hashcode一般当作地址来用。一般一次IO操作就找到对应的位置

常用的三种hash函数：直接定址（行数比较少），除留余数（），平方取中（把相对松散的key值变成一个均匀分配的hash值，数量很多，大表）

哈希冲突：闭散列（出现碰撞往后延，直到有空位），开散列（出现碰撞延伸列表）（空多 时少）

自适应哈希索引：二级索引 如果使用的次数过多，会自动生成一个hash索引使得二级又指向hashcode，直接索引到一级



位图索引

主要适用于where a = ‘a’ && a = 'b'。两个全键值匹配

相异基数低



位图联结索引

类聚簇

允许使用另外某个表的列对一个给定表简历索引 



函数索引

对F(x)的值构建索引，在通过对索引读取x所指向的记录行

1. X索引，和F(x)的索引完全不一样

应用：不区分大小写的产讯



最复杂的：字符串，日期，



系统生成键

如果插入的并发行过高，主键索引的创建资源竞争严重

解决：反向键索引，哈希索引

数据库的最小单位是一个块



为何不使用索引？

count *。对一个有索引的列做出函数索引，隐式索引

查询优化器判断使用会慢；CBO无法做出正确的选择（通过对表的内容进行处理，进行预估）



二进制编码：x86小端，大端符合人类认知。



字符串和变成数据：原始值组合到结构体，并使用固定长度的数组或指针指向其他区域



数据库文件物理组织形式通用原理：

1. 确定寻址方式
   1. 数据存储结构 一般是两类：原地更新，仅追加（方便，且保存了之前的内容，可形成多版本）
2. 



变长：分槽页



压缩：

维护：



数据库技术冲突

1. 数据密集有利于读，数据松散有利于写

链表模式的目的是优化查询效率



数据分区的问题：

1. 如果不走分区键，容易造成全表锁，或多次调用相同索引
2. 在分区中实现关联查询，就是一个灾难
3. 分区表，隐藏复杂，使得工程不可控

最难的两个问题：索引的复制问题，分区层锁定的问题（一张表 分成 十张表）



分区，分表，分库

1. 分区：把一张表的数据分成N个区块，在逻辑上最终只是一张表，但底层是N个物理区块组成
2. 分表：把一张表按照一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作



IO瓶颈：

1. 热点数据过多，缓存不够，每次查询产生大量IO——分库、垂直分表
2. 网络IO瓶颈，请求数据太多，带宽不够、链接过多——分库



全局ID



除了堆文件之外的任何存储方法都会带来复杂性

除了单库单表之外任何的存储方式，都会带来复杂性

总结：测试，设计很重要，任何设计都有时效性



## 事务处理与恢复

ACID：原子性（单个事务，为一个不可分割的最小工作单元），一致性（数据库总是从一个一致性的状态转换到另外一个一致性的状态），隔离性（通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的），持久性（一旦事务提交，则其所做的修改就会永久保存到数据库中）



缓冲区管理：

双层存储时大多数数据库的基础

页缓存。当内存中没有页副本可用时，对虚拟磁盘的读取才会访问物理存储

换入，换出，刷写



缓存的语义

缓存的修改同步是单向的

请求页的基本步骤

脏页：事务回滚（找不到啦）

目标的权衡：退出刷写，提早刷写，以最优顺序刷写



在缓存中锁定页：

该选择什么策略：首先要了解数据库的特征：（例如B+树，根节点不应该优先被刷出）

本质是预估后续页被访问的可能性

层次高的节点在大多数读取中会被命中



FIFO vs LRU

FIFO不能固定住根节点

LRU：最长时间为使用策略。但是也存在 问题：连续读叶节点

LRU-k：跟踪最近k次访问识别频繁用到的页，并使用此信息估计访问时间

如何用一个队列实现2Q：分段（70%，30%）



CLOCK：效率可能比精度更重要

用随机解决效率问题



# 【最最最最最最重要】：期末一定会有一道题有应该：直接回答是错误的，没有应该

所有的选择都是权衡





恢复：

在事务提交完成之前，把该事务所有的页面都刷新到磁盘——刷新一个完整的数据页过于浪费；随机IO刷新效率不高

undo && redo

redo log：占有空间很小，顺序写入磁盘



redo日志的设计

1. 静态结构
   1. 需要大规模的刷写
   2. 格式：type SpaceID Pagenumber Data
      1. Type:53种
      2. Data：日志的数据
         1. data = offset + data ｜｜ offset + len + data
         2. 为何有些不需要len：为了效率
   3. 所以redo日志页会比一般的Page大
   4. 顺序组织（追加型顺序）
2. 动态结构
3. 维护与优化



redo日志复杂一些的结构

一条SQL语句可能会修改很多地方（数据页面，局促，二级索引）

两个方案：

1. 每个修改的地方记录一条redo日志（多条日志）
2. 将整个页面第一个被修改的字节到最后一个被修改的字节之间所有的数据，当成一条物理redo日志的具体数据（一条日志）

或许还可以直接记录操作：逻辑层面的记录：重复执行该操作

（这边的例子：其实也考虑的是第二点：用一个start和end两条记录替代了三条记录）



物理层面 和 逻辑层面的融合日志格式

日志本质上是调用恢复函数的参数组

 

写时复制的缺点：浪费空间，会引起一些比较复杂的递归过程（B+树，叶节点存在指针的连接）

为何在B+树使用copy on write：因为B+树的深度比较浅，递归也就那几次



以足的形式写入redo：如何保证原子性（MTR）

形成一个日志组？

乐观插入（只与一个page交互），悲观插入（往往需要和多个page进行交互）

MLOG_MULTI_REC_END:作为多个redo的结束标志

第一位表示是否为单一日志





## 数据库设计——一致性保证

数据库范式：

1NF：属性的原子性

2NF：属性的逐渐完全依赖

3NF：不存在传递函数依赖

原因：为何要范式：为了满足一致性



反范式：

本质是考虑引入可控制的冗余

往往是为了读取快，降低了更新



唯一的动作就是复制

复制的根本目标就是降低连接次数



反范式模式

1. 合并1:1关系
   1. 如果是1对1，数据库默认处理的
   2. 注意部分参与的情况：这种情况案例来说不能合并
   3. 存在空值的情况，这是很讨厌的事情
2. 复制1对多关系的非Key，FK及值
   1. 如何保证一致性：前端控制（下拉框）
   2. 一般情况：可选，且可选项较少
3. 复制多对多关系的属性
   1. 不知道，看情况
   2. 需要哪个将哪个添加为属性
   3. 话费例子：添加一个还剩套餐剩余时间
4. 引入重复组
   1. 地址，电话
      1. 在cid后面加一个常用地址。
      2. 点更多地址才会进行单表查询
   2. 把有限的数据放到主表中
   3. 静态，数量较少
5. 创建提取临时表



数据库的设计：

1. 同样一个目标，满足3NF可以有多种数据模式设计
2. 不同的数据库设计
   1. 完成的功能细节不一样
   2. 相同目的的SQL，效率会有很大差异

## 自顶向下：

### 邻接模型

邻接模型：**没有描述出兄弟节点的顺序**(456都是2的子节点，但是456之间的顺序没有规定)

例子：族谱（有大哥二哥），

数据库设计的归一化原则：一事，一地，一次（上面模型不符合一地，一次）

邻接模型对程序员的要求很高（这样的表述可以表征成树，图等，为何一定是树就是程序员负责的）

深度直接影响了邻接模型的效率



如何让子节点之间有顺序？

### 物化路径模型：

1 1.1 1.1.1等等。直接构成物理化的路径

仍然不满足归一化原则

最balance的

适用场景：需求不稳定时，这一定是一个不坏的模型



### 嵌套集合模型

是一个集合论的模型

适用场景：不需要知道层次，只想知道你是谁的人。

每个节点的左右都有一个位置的值

不好的点：不能更新，加一个节点后面的所有节点都要修改

这个方法不好实现针对深度的计算。



用SQL访问树结构

自顶向下查询：Vandamme查询

最好的方法：不用mysql用oricle（有一个关键字connect by）

自顶向下：connect by parent_id = prior_id

递归实现：1.定义起始点。2.定义子节点如何影响父节点



考试直接：我用的是Oricle

老的SQL：多次连接，前提是已知深度（自己看）

还有什么方法：我修改表的结构。我增加表的大小，存的时候就存这个节点和它的所有父节点（id， pid， dis）

如何确定例如1.2.3.4.5的层数：用空去replace.，然后比较前后的长度，差就是.的个数。



效率指标：返回40条记录，循环执行每个查询5000次，比较每秒返回的记录数

数值比较效率 远远高于 字符串比较

嵌套集合：为了做深度，需要多次链接



消耗时间：from（多表链接） 》 字符串比较 〉 数值比较



### 多表模型（闭包表模型）

记录所有的节点关系。（不通过根节点的情况下，连接的关系，并额外记录彼此之间的距离）

可读性很差，你直接看不知道是图还是树。但是这个模型的通用性和扩展性很好。

用空间换了时间

需要额外检查，经过操作之后，这个表对应的是否还是一棵树？



Sample：论坛回帖

多于三层的，都放在同一层。为了避免深度太深导致效率降低



## 自底向上访问：Highland查询

领结模型：把id和pid换个位置

本质上的结果是把几棵独立的子树搜索出来了



物化路径：找到定位的节点还是很简单的



嵌套集合模型：



一些问题



## 到底哪种模型效率更高？

不知道，看情况

详细见PPT



## 其他的查询需求：对保存在叶节点的值做聚合

例如：计算每一个层的人数。BOM问题（物料单问题：任何节点可能存在多个子节点，也可能存在多个父节点）



多父节点问题如何处理？

多叉树：闭包模型。需要额外做一下check避免出现循环等错误的情况。不过具体的使用可能对节点的表还要拆解，因为有些节点是最基础的原子节点，有些是被组织起来的结果。



## 树状结构的问题



# SQL和查询优化

基于规则的优化器：所有的数据库操作分为13种操作符，每个操作符赋予一个值。



基于成本的优化算法：重点在于执行计划的成本估算.

优化的主要方向是连接

以驱动表为核心与被驱动表连接（大概率一条一条跑效率最高）



外连接：

分左右：制定SQL语法，需要制定哪一张表是驱动表，需要考虑要保留驱动表的数据还是被驱动表的数据。

谁先连接谁是很重要的：如何理解好条件（性别 = “女”）。查询优化器能做简单的估算（前提是数据是均匀分布的，sb程序给一个700000）



嵌套循环连接：驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数 的连接执行方式称为 嵌套循环连接。

使用索引加速连接

1. 被驱动表有索引的情况下，被驱动表驱动被驱动表筛选的数据进行多次给予索引的查询
2. 如果有多个条件，需要有多个索引，优化器选择某个索引
3. 连接查询和过滤条件一般只涉及被驱动表的部分列，

基于块的连接优化：T2的部分数据和T1的数据全连接

1. 尽量减少访问被驱动表的次数（驱动表的记录不会都放入join buffer，只会将部分列放入）
2. 【没有记完】



连接的小结：

1. 本质上，连接就是把各个表中的记录都取出来依次进行匹配，并把匹配的组合返回
2. 内连接和外链接的本质都是确定驱动表
3. 嵌套循环连接算法：驱动表只访问一次，但被驱动表可能会访问多次，访问次数取决于被驱动表执行单表查询后结果集中有多少条记录。
4. 被驱动表会被多次访问，建立合适的索引
5. 被驱动表很大，多次访问会导致更多的磁盘IO，使用基于块的嵌套索引算法



什么是成本？

一个查询有多个执行方案，会选择其中成本最低的。

成本有两个方面：

1. IO成本（物理读默认成本1.0）
2. CPU成本（逻辑读和检测默认成本0.2）

基于成本的优化：

1. 根据搜索条件，找出所有可能使用的索引。
2. 计算全表扫描的代价
3. 计算使用不同索引的代价



两表连接的成本分析

1. 连接查询的总成本 = 单词访问驱动表的成本 + 驱动表扇出值 * 单词背驱动表的成本
2. 寻找成嫩最低的
3. 多表连接类似，只是可选路径为N的阶乘
   1. 提前结束某种连接顺序的成本
   2. 设置系统变量决定连接深度
   3. 不考虑连接顺序，使用学习的启发式规则



调节成本常数



查询成本的小结：

【PPT上有，没有记完】

1. 一个查询成本由IO成本 和 CPU成本组成
2. 基本步骤
3. 驱动表的扇出值是预测出来的
   1. 最优化表连接
   2. 为驱动表和被驱动表选择成本最低的访问方式

【PPT上有，没有记完】



查询优化器重要的一点

1. 实现关系代数的花间和优化，依赖于数据系统的物理性质
   1. 存储设备的特性
   2. 存储结构的基本特征
   3. 元数据和预计算结果
   4. 聚合和计算单元的特性
2. 所以几乎所有的查询优化器都遵循一个底层原理，但实现端呈现巨大差异
3. 对数据库而言：**好条件要先做**【请刻在基因里】



SQL的执行顺序

SQL -- 语义语法检查 -- 解析（最消耗资源） -- 执行计划 -- 执行引擎 -- 存储引擎 -- 数据库



软解析：被解析过了，绑定变量（常量转化为变量）

硬解析：SQL转关系代数

SQL注入。把相似的查询变成一次查询。不需要再走一遍之前的例如成本判断等。

需要考虑绑定变量存在的问题，软解析解决了这个问题，因为他已经预先解析好了，不会导致SQL的结构发生变化。

软解析的缺点在哪里？数值可以帮助我们估计，如果绑定，对所有的范围查询，只能用平均值进行估算。



Order by的出现的时机比较重要



优化器的有效范围：

1. 优化器需要借助数据库中找到的信息
2. 能够进行数学意义上的等价变化
3. 优化器考虑整体响应时间
4. 优化器改善的是独立的查询



使用SQL需要考虑的因素

1. 所需访问的数据量（决定了你的SQL下限）
2. 定义结果集所需的查询条件
3. 结果集的大小
4. 获得结果集所涉及的表的数量
5. 同时修改这些数据用户的多少



// 两个重点需要考虑的因素没有听到



表的数量

复杂查询和复杂视图

基本原则为：当是视图返回的数据远多于上级查询所需的时候，就放弃使用这个视图



并发用户数

需要考虑：数据块访问争用，阻塞，闩定，保证读取一致性

整体吞吐量 > 个体响应时间



查询的过滤条件

1. 如何限定结果集是最为关键的因素
2. 也是使用SQL各种技巧的判断因素

where子句 和 having子句

join过滤条件

select过滤条件



过滤条件的好坏：

古老的自然连接方式：需要使用distinct，同时注意连接（还有个小问题：distinct会导致同名的结果被失去）

哪个条件好，我们先做哪个条件

进一步建议：避免在最高层distinct是一条基本原则 ====== > 一般采用嵌套查询（exists「有无满足条件的结果集」 和 in「」）

exists（关联嵌套子查询）：遍历外部的全部记录，做两件事，1， 先判断where后面的外层条件，不满足则剔除，2. 再进入嵌套查询的内部，如果符合就保留了，否则被剔除。**暗示了以C为主驱动表**。是存在性测试（select null）

扇出数量：主驱动表满足nanjing的数量

2个效率高的情况：扇出数少（说明先做的是好条件），外键有索引（orders这张表）。

潜在的（是global的，且只卖BMW的）

嵌套查询会快速返回的条件（南京这个条件非常好，买了BMW的这个条件很差，很快的找到第一条记录）



in（非关联子查询）

内层查询不再依赖外层查询，只需要执行一次（把所有满足要求的结果都取出来）

非关联子查询不需要，因为要用到的索引是customers的主键索引

大的结果集需要优化：条件好，结果集小（就是交给查询优化器）；额外对结果集进行处理



还可以进行进一步的嵌套

in里面还有exitst，in里面还有in



对很多数据库，非关联子查询还可以写成from子句的内嵌视图



* 解决方案往往不止一种，查询和数据隐含的假设密切相关
* 预先考虑优化器的工作



Any：任何一个

如果子查询结果集存在小于的列，则表达式值为true



All：全部都是

如果查询的结果集中所有值都小于列，则表达式值为true



## SQL优化的其他问题



大数据量查询

* 越快剔除不需要的数据，查询的后续阶段必须处理的数据量就越少，查询效率越高



将子查询转换为join

不包含聚合函数，不出现多种条件选择可以不需要子查询



查询不存在的内容：外连接



非关联子查询变成内嵌视图



## SQL实例解析

SQL的指定顺序：select from where group by having order by limit

Group by后面只能放分组标志符和聚合函数



group by是在where子句之后执行的

where子句无法与聚合函数一起使用



 select子句中可以放置的内容：用户定义的函数，窗口函数，非关联的标量子查询返回的常量，标量值



count(*)哪怕有空值还是会算，但是如果count对某个字段，如果是空值，就直接删去。所以有时候需要用count(*)

### 字符串处理

主要是数据清洗

想要处理分离数字和字符数据：用正则表达式



### 数值处理

主要是数据处理



Case的使用

## 常见SQL连接模式

叠加行集

union & union all

使用union数量和字段都要一样

union等同于针对union all的输出结果，再执行一次distinct操作



差

minus，except，not in（如果后面有NULL，可能会出现false or false or NULL）

* 使用not in的时候小心null











































