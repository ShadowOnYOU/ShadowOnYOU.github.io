---
layout: post
title: 嵌入式系统——实时内核（存储管理、时钟）
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

# 嵌入式系统——实时内核（存储管理、时钟）

主要还是存储，时钟算是一种注意事项

## 1. 存储

μC/OS中是实模式存储管理

### malloc/free

ANSI C中动态的分配内存和释放内存，容易产生碎片

µC/OS-II对malloc和free进行了改进，使得它们可以分配和释放固定大小的内存块，函数的执行时间也固定

![截屏2023-12-11 上午10.16.46](https://github.com/ShadowOnYOU/images/blob/main/test202312111016966.png?raw=true)

#### 两个函数存在的一些问题

1. 在小型嵌入式系统中可能不可用
2. 具体实现可能会相对较大，会占用较多的代码空间
3. 通常不具备线程安全特性
4. 具有不确定性，每次调用的时间和开销可能不同
5. 会产生内存碎片
6. 会使得连接器配置的复杂

#### µC/OS的处理方法

采用的是固定分区的存储管理方法

把连续的大块内存按分区来管理，每个分区包含有整数个大小相同的块

在一个系统中可以有多个内存分区，用户的应用程序可以从不同的内存分区中得到不同大小的内存块，但特定的内存块在释放时**必须重新放回到它以前所属于的内存分区**

![截屏2023-12-11 上午10.21.20](https://github.com/ShadowOnYOU/images/blob/main/test202312111021805.png?raw=true)

#### 内存控制块 MCB

µC/OS中使用MCB来跟踪每一个内存分区，每个内存分区都有自己的MCB

![截屏2023-12-11 上午10.23.10](https://github.com/ShadowOnYOU/images/blob/main/test202312111023265.png?raw=true)

也是链表的形式进行组织

#### OSMenCreate()

![截屏2023-12-11 上午10.24.48](https://github.com/ShadowOnYOU/images/blob/main/test202312111024510.png?raw=true)

##### 内部的具体实现

![截屏2023-12-11 上午10.25.27](https://github.com/ShadowOnYOU/images/blob/main/test202312111025353.png?raw=true)

每一块的大小至少是8个字节（至少有一个指针32位）

#### OSMemGet()

从已经建立的内存分区中申请一个内存块

该函数的唯一参数时指向特定内存分区的指针

如果没有闲置可用，返回null指针

#### OSMemPut()

将一个内存块释放并返回到相应的内存分区中

* 用户程序必须确认将内存块放回到了正确的内存分区中，因为Put函数不知道一个内存块时属于哪个内存分区的

#### 等待内存块

能否在没有空闲内存块时让任务进入等待状态

本身不支持，如果需要可以通过位特定内存分区增加信号量的方法实现此功能

### freertos的内存管理

三种实现范例

#### 1. Heap_1.c

![截屏2023-12-11 上午10.36.09](https://github.com/ShadowOnYOU/images/blob/main/test202312111036116.png?raw=true)

#### 2. Heap_2.c

采用了一个最佳匹配算法（会使用最接近大小的空间块）来分配内存，并支持内存释放

声明了一个静态数组，让整个应用程序看起来耗费了很多内存

不会吧相邻的空闲块合并成一个更大的内存块，所以会产生内存碎片

适合于那些重复创建于删除具有相同空间任务的应用程序

![截屏2023-12-11 上午10.41.25](https://github.com/ShadowOnYOU/images/blob/main/test202312111041006.png?raw=true)

#### 3. Heap_3.c

简单调用了标准库malloc和free，但是通过暂时挂起调度器使得函数调用具备了线程安全特性

## 2. 时钟

### 时钟节拍

时钟节拍时一种特殊的终端，

μC/OS需要用户提供周期性信号源，用于实现时间延时和确认超时

节拍率越高，系统的额外负荷就越重

* 由于时钟节拍函数返回null，你可以自己设定在函数内部做一些事情

1. `OSTimeTickHook()` 是一个函数调用，表示执行定时器中断处理函数的钩子（hook）。它可以是用户定义的函数，用于在每次定时器中断时执行特定的操作。
2. `ptcb` 是一个指向任务控制块（Task Control Block，TCB）的指针。`OSTCBList` 是一个指向任务列表的指针，这里将其赋值给 `ptcb`，表示从任务列表的头部开始遍历。
3. 这是一个循环，遍历任务列表中的任务控制块，直到找到一个具有空闲优先级（`OS_IDLE_PRIO`）的任务控制块，表示遍历结束。
4. 这是一个条件判断语句，检查当前任务控制块的延时计数（`OSTCBDly`）是否为零。如果不为零，表示任务还在延时状态，需要继续延时。
5. 如果延时计数减一后变为零，并且任务状态（`OSTCBStat`）没有被挂起（`OS_STAT_SUSPEND`），则将当前任务的就绪组（`OSTCBBitY`）设置为就绪位图（`OSRdyGrp`）的相应位，表示该任务已经准备好运行。同时，将当前任务的就绪表（`OSTCBBitX`）设置为就绪表（`OSRdyTbl`）的相应位，表示该任务所属的优先级已经准备好运行。
6. 退出临界区保护，这里将进入临界区保护，以确保在执行关键操作时不被其他中断打断。
7. `OSTime` 是一个全局变量，表示系统的时间计数器。这里将系统时间增加1，表示经过了一单位的时间。

### 时间管理

OSTimeDLY

OSTimeDLYHMSM

OSTimeDlyResume

OSTimeGet

OSTimeSet

需要注意的一点：节拍数为1时

![截屏2023-12-11 上午10.55.00](https://github.com/ShadowOnYOU/images/blob/main/test202312111055120.png?raw=true)

实际没有到一个时钟节拍，但是由于动态执行的关系，实际只休眠了5ms

![截屏2023-12-11 上午10.59.12](https://github.com/ShadowOnYOU/images/blob/main/test202312111059482.png?raw=true)

![截屏2023-12-11 上午10.59.27](https://github.com/ShadowOnYOU/images/blob/main/test202312111059783.png?raw=true)

#### 可能的解决方法



## 3. 板级支持包与系统引导

### 嵌入式软件运行流程

![截屏2023-12-11 上午11.12.42](https://github.com/ShadowOnYOU/images/blob/main/test202312111112458.png?raw=true)

#### 1. 上电复位，板级初始化阶段

上电复位后完成板级初始化工作

选择引导或升级

板级初始化程序具有完全的硬件特性，一般采用汇编语言实现。不同的嵌入式 系统，板级初始化时要完成的工作具有一定的特殊性，但以下工作一般是必须 完成的： CPU中堆栈指针寄存器的初始化 BSS段（Block Storage Space表示未被初始化的数据）的初始化 CPU芯片级的初始化：中断控制器、内存等的初始化 

#### 2. 系统引导/升级阶段

#### 3. 系统引导阶段

将系统软件从NOR Flash中读取出来加载到RAM中运行：这种方式可以解决 成本及Flash速度比RAM慢的问题，软件可压缩存储在Flash中 

不需将软件引导到RAM中而是让其直接在NorFlash上运行，进入系统初始化 阶段 

将软件从外存（如NandFlash、CF卡、MMC等）中读取出来加载到RAM中 运行：这种方式的成本更低 

XIP：指直接在存储器（通常是闪存）上执行代码，而无需将代码复制到RAM中运行

#### 4. 系统升级阶段

通过网络进行远程升级或通过串口进行本地升级

本地升级可以通过Console口使用超级终端或特定的升级软件进行

#### 5.系统初始化阶段

在该阶段进行操作系统等系统软件各功能部分必需的初始化工作，如根据系统 配置初始化数据空间、初始化系统所需的接口和外设等 

系统初始化阶段需要按特定顺序进行，如首先完成内核的初始化，然后完成网 络、文件系统等的初始化，最后完成中间件等的初始化工作 

#### 6. 应用初始化阶段 && 多任务应用运行阶段

### 板级支持包BSP

简单来说就是一段启动代码，和BIOS差不多

![截屏2023-12-11 上午11.22.52](https://github.com/ShadowOnYOU/images/blob/main/test202312111122680.png?raw=true)

#### 驱动程序

抽象物理设备或虚拟设备的功能软件

基本功能：

1. 对手河北初始化和释放
2. 对设备进行管理
3. 读取应用程序传送给设备文件的数据，并回送应用程序的请求数据
4. 检测和处理设备出现的错误

#### BSP和BIOS的区别

BIOS主要是负责在电脑开启时检测、初始化系统设备（设置栈指针， 中断分配，内存初始化..）、装入操作系统并调度操作系统向硬件发出 的指令。 UEFI,“统一的可扩展固件接口”, 旨在代替BIOS, 提高软 件互操作性和解决BIOS的局限性 

BSP是和操作系统绑在一起运行，尽管BSP的开始部分和BIOS所做 的工作类似，但是 BSP还包含和系统有关的**基本驱动** 

BIOS程序是用户**不能更改**，编译编程的，只能对参数进行修改设置， 但是程序员还可以编程修改BSP，在BSP中任意添加一些和系统无关 的驱动或程序，甚至可以把上层开发的统统放到BSP中

#### BSP特点

1. 硬件相关性
2. 操作系统相关性

#### 嵌入式系统初始化 && BSP功能

初始化：包括硬件初始化和软件初始化

抽象：片级初始化，板级初始化，系统级初始化

##### 片级初始化

主要完成CPU的初始化 

设置CPU的核心寄存器和控制寄存器 

CPU核心工作模式 

CPU的局部总线模式等 

片级初始化把CPU从上电时的缺省状态逐步设置成为系统所要求的工作状态 

这是一个纯硬件的初始化过程

##### 板级初始化

完成CPU以外的其他硬件设备的初始化 

同时还要设置某些软件的数据结构和参数，为随后的系统级初始化和应用程序 的运行建立硬件和软件环境 

这是一个同时包含软硬件两部分在内的初始化过程

##### 系统级初始化

这是一个以软件初始化为主的过程，主要进行操作系统初始化 

BSP将控制转交给操作系统，由操作系统进行余下的初始化操作： 

包括加载和初始化与硬件无关的设备驱动程序 

建立系统内存区 

加载并初始化其他系统软件模块（如网络系统、文件系统等） 

最后，操作系统创建应用程序环境并将控制转交给应用程序的入口

### Bootloader

嵌入式系统的OS启动加载程序

#### 引导加载程序

包括固化在固件(firmware)中的 boot 代码(可选)，和 Boot Loader两大部分 是系统加电后运行的第一段软件代码（对于操作系统内核来说是一个硬件抽象层）

#### 引导模式的模式：

不需要BL：时间效率高，系统快速启动，直接在NOR flash或ROM系列非易失性存储介质中运行，但不满足运行速度的要求（可以直接进行执行）

需要BL：节省空间，牺牲时间，适用于硬件成本低，运 行速度快，但启动速度相对慢

### PC机中的BL && 嵌入式系统中的BL

![截屏2023-12-11 上午11.42.12](https://github.com/ShadowOnYOU/images/blob/main/test202312111142115.png?raw=true)

![截屏2023-12-11 上午11.42.53](https://github.com/ShadowOnYOU/images/blob/main/test202312111142786.png?raw=true)

#### 固态存储设备额度典型空间分配结构

bootloader -- 启动参数 -- 内核 -- 根文件系统

#### 用于控制BL的设备或机制

主机和目标机之间一般通过串口建立连接

BL执行时通常会通过串口进行IO

#### BL的启动单阶段 && 多阶段

#### BL与主机之间进行文件传输所用的通信设备及协议

#### BL的调试

## 4. U-boot

开源项目

其源码目录、编译形式与Linux内核很相似

源码就是相应Linux内核源程序的简化，尤其是设备驱动程序

也需要瘦身，要放在ROM里？？？
